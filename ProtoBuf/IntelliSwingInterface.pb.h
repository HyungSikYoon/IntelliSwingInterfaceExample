// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IntelliSwingInterface.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_IntelliSwingInterface_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_IntelliSwingInterface_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/empty.pb.h>
#include "type.pb.h"
#include "IntelliSwingService.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_IntelliSwingInterface_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_IntelliSwingInterface_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_IntelliSwingInterface_2eproto;
namespace IntelliSwing {
class ImageData;
struct ImageDataDefaultTypeInternal;
extern ImageDataDefaultTypeInternal _ImageData_default_instance_;
class ImageData_Image;
struct ImageData_ImageDefaultTypeInternal;
extern ImageData_ImageDefaultTypeInternal _ImageData_Image_default_instance_;
class ImageData_Image_Marker;
struct ImageData_Image_MarkerDefaultTypeInternal;
extern ImageData_Image_MarkerDefaultTypeInternal _ImageData_Image_Marker_default_instance_;
class InitializeMsg;
struct InitializeMsgDefaultTypeInternal;
extern InitializeMsgDefaultTypeInternal _InitializeMsg_default_instance_;
class ReleaseMsg;
struct ReleaseMsgDefaultTypeInternal;
extern ReleaseMsgDefaultTypeInternal _ReleaseMsg_default_instance_;
class SensorRunningMsg;
struct SensorRunningMsgDefaultTypeInternal;
extern SensorRunningMsgDefaultTypeInternal _SensorRunningMsg_default_instance_;
class SensorRunningMsg_BallFlightInfo;
struct SensorRunningMsg_BallFlightInfoDefaultTypeInternal;
extern SensorRunningMsg_BallFlightInfoDefaultTypeInternal _SensorRunningMsg_BallFlightInfo_default_instance_;
class SensorRunningMsg_ClubPathInfo;
struct SensorRunningMsg_ClubPathInfoDefaultTypeInternal;
extern SensorRunningMsg_ClubPathInfoDefaultTypeInternal _SensorRunningMsg_ClubPathInfo_default_instance_;
class SensorRunningMsg_ClubPathInfo_ClubPath;
struct SensorRunningMsg_ClubPathInfo_ClubPathDefaultTypeInternal;
extern SensorRunningMsg_ClubPathInfo_ClubPathDefaultTypeInternal _SensorRunningMsg_ClubPathInfo_ClubPath_default_instance_;
class SensorRunningMsg_Heartbeat;
struct SensorRunningMsg_HeartbeatDefaultTypeInternal;
extern SensorRunningMsg_HeartbeatDefaultTypeInternal _SensorRunningMsg_Heartbeat_default_instance_;
class SensorRunningMsg_NotReady;
struct SensorRunningMsg_NotReadyDefaultTypeInternal;
extern SensorRunningMsg_NotReadyDefaultTypeInternal _SensorRunningMsg_NotReady_default_instance_;
class SensorRunningMsg_Ready;
struct SensorRunningMsg_ReadyDefaultTypeInternal;
extern SensorRunningMsg_ReadyDefaultTypeInternal _SensorRunningMsg_Ready_default_instance_;
class SensorRunningMsg_ShortTriggered;
struct SensorRunningMsg_ShortTriggeredDefaultTypeInternal;
extern SensorRunningMsg_ShortTriggeredDefaultTypeInternal _SensorRunningMsg_ShortTriggered_default_instance_;
class ShotImageRequest;
struct ShotImageRequestDefaultTypeInternal;
extern ShotImageRequestDefaultTypeInternal _ShotImageRequest_default_instance_;
class StartMsg;
struct StartMsgDefaultTypeInternal;
extern StartMsgDefaultTypeInternal _StartMsg_default_instance_;
}  // namespace IntelliSwing
PROTOBUF_NAMESPACE_OPEN
template<> ::IntelliSwing::ImageData* Arena::CreateMaybeMessage<::IntelliSwing::ImageData>(Arena*);
template<> ::IntelliSwing::ImageData_Image* Arena::CreateMaybeMessage<::IntelliSwing::ImageData_Image>(Arena*);
template<> ::IntelliSwing::ImageData_Image_Marker* Arena::CreateMaybeMessage<::IntelliSwing::ImageData_Image_Marker>(Arena*);
template<> ::IntelliSwing::InitializeMsg* Arena::CreateMaybeMessage<::IntelliSwing::InitializeMsg>(Arena*);
template<> ::IntelliSwing::ReleaseMsg* Arena::CreateMaybeMessage<::IntelliSwing::ReleaseMsg>(Arena*);
template<> ::IntelliSwing::SensorRunningMsg* Arena::CreateMaybeMessage<::IntelliSwing::SensorRunningMsg>(Arena*);
template<> ::IntelliSwing::SensorRunningMsg_BallFlightInfo* Arena::CreateMaybeMessage<::IntelliSwing::SensorRunningMsg_BallFlightInfo>(Arena*);
template<> ::IntelliSwing::SensorRunningMsg_ClubPathInfo* Arena::CreateMaybeMessage<::IntelliSwing::SensorRunningMsg_ClubPathInfo>(Arena*);
template<> ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath* Arena::CreateMaybeMessage<::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath>(Arena*);
template<> ::IntelliSwing::SensorRunningMsg_Heartbeat* Arena::CreateMaybeMessage<::IntelliSwing::SensorRunningMsg_Heartbeat>(Arena*);
template<> ::IntelliSwing::SensorRunningMsg_NotReady* Arena::CreateMaybeMessage<::IntelliSwing::SensorRunningMsg_NotReady>(Arena*);
template<> ::IntelliSwing::SensorRunningMsg_Ready* Arena::CreateMaybeMessage<::IntelliSwing::SensorRunningMsg_Ready>(Arena*);
template<> ::IntelliSwing::SensorRunningMsg_ShortTriggered* Arena::CreateMaybeMessage<::IntelliSwing::SensorRunningMsg_ShortTriggered>(Arena*);
template<> ::IntelliSwing::ShotImageRequest* Arena::CreateMaybeMessage<::IntelliSwing::ShotImageRequest>(Arena*);
template<> ::IntelliSwing::StartMsg* Arena::CreateMaybeMessage<::IntelliSwing::StartMsg>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace IntelliSwing {

enum InitializeMsg_Client : int {
  InitializeMsg_Client_GDR = 0,
  InitializeMsg_Client_NextGDR = 1,
  InitializeMsg_Client_Vision = 2,
  InitializeMsg_Client_Ohter = 3,
  InitializeMsg_Client_InitializeMsg_Client_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  InitializeMsg_Client_InitializeMsg_Client_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool InitializeMsg_Client_IsValid(int value);
constexpr InitializeMsg_Client InitializeMsg_Client_Client_MIN = InitializeMsg_Client_GDR;
constexpr InitializeMsg_Client InitializeMsg_Client_Client_MAX = InitializeMsg_Client_Ohter;
constexpr int InitializeMsg_Client_Client_ARRAYSIZE = InitializeMsg_Client_Client_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InitializeMsg_Client_descriptor();
template<typename T>
inline const std::string& InitializeMsg_Client_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InitializeMsg_Client>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InitializeMsg_Client_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InitializeMsg_Client_descriptor(), enum_t_value);
}
inline bool InitializeMsg_Client_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InitializeMsg_Client* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InitializeMsg_Client>(
    InitializeMsg_Client_descriptor(), name, value);
}
enum StartMsg_ClubInformation : int {
  StartMsg_ClubInformation_PT = 0,
  StartMsg_ClubInformation_Wood = 100,
  StartMsg_ClubInformation_W1 = 101,
  StartMsg_ClubInformation_W2 = 102,
  StartMsg_ClubInformation_W3 = 103,
  StartMsg_ClubInformation_W4 = 104,
  StartMsg_ClubInformation_W5 = 105,
  StartMsg_ClubInformation_Iron = 200,
  StartMsg_ClubInformation_I3 = 203,
  StartMsg_ClubInformation_I4 = 204,
  StartMsg_ClubInformation_I5 = 205,
  StartMsg_ClubInformation_I6 = 206,
  StartMsg_ClubInformation_I7 = 207,
  StartMsg_ClubInformation_I8 = 208,
  StartMsg_ClubInformation_I9 = 209,
  StartMsg_ClubInformation_Wedge = 300,
  StartMsg_ClubInformation_PW = 310,
  StartMsg_ClubInformation_SW = 320,
  StartMsg_ClubInformation_Hybrid = 400,
  StartMsg_ClubInformation_StartMsg_ClubInformation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StartMsg_ClubInformation_StartMsg_ClubInformation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StartMsg_ClubInformation_IsValid(int value);
constexpr StartMsg_ClubInformation StartMsg_ClubInformation_ClubInformation_MIN = StartMsg_ClubInformation_PT;
constexpr StartMsg_ClubInformation StartMsg_ClubInformation_ClubInformation_MAX = StartMsg_ClubInformation_Hybrid;
constexpr int StartMsg_ClubInformation_ClubInformation_ARRAYSIZE = StartMsg_ClubInformation_ClubInformation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StartMsg_ClubInformation_descriptor();
template<typename T>
inline const std::string& StartMsg_ClubInformation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StartMsg_ClubInformation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StartMsg_ClubInformation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StartMsg_ClubInformation_descriptor(), enum_t_value);
}
inline bool StartMsg_ClubInformation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StartMsg_ClubInformation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StartMsg_ClubInformation>(
    StartMsg_ClubInformation_descriptor(), name, value);
}
// ===================================================================

class InitializeMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.InitializeMsg) */ {
 public:
  inline InitializeMsg() : InitializeMsg(nullptr) {}
  ~InitializeMsg() override;
  explicit constexpr InitializeMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitializeMsg(const InitializeMsg& from);
  InitializeMsg(InitializeMsg&& from) noexcept
    : InitializeMsg() {
    *this = ::std::move(from);
  }

  inline InitializeMsg& operator=(const InitializeMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitializeMsg& operator=(InitializeMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitializeMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitializeMsg* internal_default_instance() {
    return reinterpret_cast<const InitializeMsg*>(
               &_InitializeMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InitializeMsg& a, InitializeMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(InitializeMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitializeMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitializeMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitializeMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitializeMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InitializeMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitializeMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.InitializeMsg";
  }
  protected:
  explicit InitializeMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef InitializeMsg_Client Client;
  static constexpr Client GDR =
    InitializeMsg_Client_GDR;
  static constexpr Client NextGDR =
    InitializeMsg_Client_NextGDR;
  static constexpr Client Vision =
    InitializeMsg_Client_Vision;
  static constexpr Client Ohter =
    InitializeMsg_Client_Ohter;
  static inline bool Client_IsValid(int value) {
    return InitializeMsg_Client_IsValid(value);
  }
  static constexpr Client Client_MIN =
    InitializeMsg_Client_Client_MIN;
  static constexpr Client Client_MAX =
    InitializeMsg_Client_Client_MAX;
  static constexpr int Client_ARRAYSIZE =
    InitializeMsg_Client_Client_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Client_descriptor() {
    return InitializeMsg_Client_descriptor();
  }
  template<typename T>
  static inline const std::string& Client_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Client>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Client_Name.");
    return InitializeMsg_Client_Name(enum_t_value);
  }
  static inline bool Client_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Client* value) {
    return InitializeMsg_Client_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kClientFieldNumber = 4,
  };
  // .IntelliSwing.InitializeMsg.Client client = 4;
  void clear_client();
  ::IntelliSwing::InitializeMsg_Client client() const;
  void set_client(::IntelliSwing::InitializeMsg_Client value);
  private:
  ::IntelliSwing::InitializeMsg_Client _internal_client() const;
  void _internal_set_client(::IntelliSwing::InitializeMsg_Client value);
  public:

  // @@protoc_insertion_point(class_scope:IntelliSwing.InitializeMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int client_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingInterface_2eproto;
};
// -------------------------------------------------------------------

class ReleaseMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.ReleaseMsg) */ {
 public:
  inline ReleaseMsg() : ReleaseMsg(nullptr) {}
  ~ReleaseMsg() override;
  explicit constexpr ReleaseMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReleaseMsg(const ReleaseMsg& from);
  ReleaseMsg(ReleaseMsg&& from) noexcept
    : ReleaseMsg() {
    *this = ::std::move(from);
  }

  inline ReleaseMsg& operator=(const ReleaseMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleaseMsg& operator=(ReleaseMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReleaseMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReleaseMsg* internal_default_instance() {
    return reinterpret_cast<const ReleaseMsg*>(
               &_ReleaseMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ReleaseMsg& a, ReleaseMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(ReleaseMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleaseMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReleaseMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReleaseMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReleaseMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReleaseMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReleaseMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.ReleaseMsg";
  }
  protected:
  explicit ReleaseMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:IntelliSwing.ReleaseMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingInterface_2eproto;
};
// -------------------------------------------------------------------

class StartMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.StartMsg) */ {
 public:
  inline StartMsg() : StartMsg(nullptr) {}
  ~StartMsg() override;
  explicit constexpr StartMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartMsg(const StartMsg& from);
  StartMsg(StartMsg&& from) noexcept
    : StartMsg() {
    *this = ::std::move(from);
  }

  inline StartMsg& operator=(const StartMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartMsg& operator=(StartMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartMsg* internal_default_instance() {
    return reinterpret_cast<const StartMsg*>(
               &_StartMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StartMsg& a, StartMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(StartMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StartMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.StartMsg";
  }
  protected:
  explicit StartMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StartMsg_ClubInformation ClubInformation;
  static constexpr ClubInformation PT =
    StartMsg_ClubInformation_PT;
  static constexpr ClubInformation Wood =
    StartMsg_ClubInformation_Wood;
  static constexpr ClubInformation W1 =
    StartMsg_ClubInformation_W1;
  static constexpr ClubInformation W2 =
    StartMsg_ClubInformation_W2;
  static constexpr ClubInformation W3 =
    StartMsg_ClubInformation_W3;
  static constexpr ClubInformation W4 =
    StartMsg_ClubInformation_W4;
  static constexpr ClubInformation W5 =
    StartMsg_ClubInformation_W5;
  static constexpr ClubInformation Iron =
    StartMsg_ClubInformation_Iron;
  static constexpr ClubInformation I3 =
    StartMsg_ClubInformation_I3;
  static constexpr ClubInformation I4 =
    StartMsg_ClubInformation_I4;
  static constexpr ClubInformation I5 =
    StartMsg_ClubInformation_I5;
  static constexpr ClubInformation I6 =
    StartMsg_ClubInformation_I6;
  static constexpr ClubInformation I7 =
    StartMsg_ClubInformation_I7;
  static constexpr ClubInformation I8 =
    StartMsg_ClubInformation_I8;
  static constexpr ClubInformation I9 =
    StartMsg_ClubInformation_I9;
  static constexpr ClubInformation Wedge =
    StartMsg_ClubInformation_Wedge;
  static constexpr ClubInformation PW =
    StartMsg_ClubInformation_PW;
  static constexpr ClubInformation SW =
    StartMsg_ClubInformation_SW;
  static constexpr ClubInformation Hybrid =
    StartMsg_ClubInformation_Hybrid;
  static inline bool ClubInformation_IsValid(int value) {
    return StartMsg_ClubInformation_IsValid(value);
  }
  static constexpr ClubInformation ClubInformation_MIN =
    StartMsg_ClubInformation_ClubInformation_MIN;
  static constexpr ClubInformation ClubInformation_MAX =
    StartMsg_ClubInformation_ClubInformation_MAX;
  static constexpr int ClubInformation_ARRAYSIZE =
    StartMsg_ClubInformation_ClubInformation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ClubInformation_descriptor() {
    return StartMsg_ClubInformation_descriptor();
  }
  template<typename T>
  static inline const std::string& ClubInformation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ClubInformation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ClubInformation_Name.");
    return StartMsg_ClubInformation_Name(enum_t_value);
  }
  static inline bool ClubInformation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ClubInformation* value) {
    return StartMsg_ClubInformation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kClubInformationFieldNumber = 1,
  };
  // .IntelliSwing.StartMsg.ClubInformation clubInformation = 1;
  void clear_clubinformation();
  ::IntelliSwing::StartMsg_ClubInformation clubinformation() const;
  void set_clubinformation(::IntelliSwing::StartMsg_ClubInformation value);
  private:
  ::IntelliSwing::StartMsg_ClubInformation _internal_clubinformation() const;
  void _internal_set_clubinformation(::IntelliSwing::StartMsg_ClubInformation value);
  public:

  // @@protoc_insertion_point(class_scope:IntelliSwing.StartMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int clubinformation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingInterface_2eproto;
};
// -------------------------------------------------------------------

class SensorRunningMsg_Ready final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.SensorRunningMsg.Ready) */ {
 public:
  inline SensorRunningMsg_Ready() : SensorRunningMsg_Ready(nullptr) {}
  ~SensorRunningMsg_Ready() override;
  explicit constexpr SensorRunningMsg_Ready(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorRunningMsg_Ready(const SensorRunningMsg_Ready& from);
  SensorRunningMsg_Ready(SensorRunningMsg_Ready&& from) noexcept
    : SensorRunningMsg_Ready() {
    *this = ::std::move(from);
  }

  inline SensorRunningMsg_Ready& operator=(const SensorRunningMsg_Ready& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorRunningMsg_Ready& operator=(SensorRunningMsg_Ready&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorRunningMsg_Ready& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorRunningMsg_Ready* internal_default_instance() {
    return reinterpret_cast<const SensorRunningMsg_Ready*>(
               &_SensorRunningMsg_Ready_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SensorRunningMsg_Ready& a, SensorRunningMsg_Ready& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorRunningMsg_Ready* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorRunningMsg_Ready* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorRunningMsg_Ready* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorRunningMsg_Ready>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorRunningMsg_Ready& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SensorRunningMsg_Ready& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorRunningMsg_Ready* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.SensorRunningMsg.Ready";
  }
  protected:
  explicit SensorRunningMsg_Ready(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kIsTeeFieldNumber = 2,
  };
  // .IntelliSwing.Point3f position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::IntelliSwing::Point3f& position() const;
  PROTOBUF_NODISCARD ::IntelliSwing::Point3f* release_position();
  ::IntelliSwing::Point3f* mutable_position();
  void set_allocated_position(::IntelliSwing::Point3f* position);
  private:
  const ::IntelliSwing::Point3f& _internal_position() const;
  ::IntelliSwing::Point3f* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::IntelliSwing::Point3f* position);
  ::IntelliSwing::Point3f* unsafe_arena_release_position();

  // bool isTee = 2;
  void clear_istee();
  bool istee() const;
  void set_istee(bool value);
  private:
  bool _internal_istee() const;
  void _internal_set_istee(bool value);
  public:

  // @@protoc_insertion_point(class_scope:IntelliSwing.SensorRunningMsg.Ready)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::IntelliSwing::Point3f* position_;
  bool istee_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingInterface_2eproto;
};
// -------------------------------------------------------------------

class SensorRunningMsg_NotReady final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:IntelliSwing.SensorRunningMsg.NotReady) */ {
 public:
  inline SensorRunningMsg_NotReady() : SensorRunningMsg_NotReady(nullptr) {}
  explicit constexpr SensorRunningMsg_NotReady(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorRunningMsg_NotReady(const SensorRunningMsg_NotReady& from);
  SensorRunningMsg_NotReady(SensorRunningMsg_NotReady&& from) noexcept
    : SensorRunningMsg_NotReady() {
    *this = ::std::move(from);
  }

  inline SensorRunningMsg_NotReady& operator=(const SensorRunningMsg_NotReady& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorRunningMsg_NotReady& operator=(SensorRunningMsg_NotReady&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorRunningMsg_NotReady& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorRunningMsg_NotReady* internal_default_instance() {
    return reinterpret_cast<const SensorRunningMsg_NotReady*>(
               &_SensorRunningMsg_NotReady_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SensorRunningMsg_NotReady& a, SensorRunningMsg_NotReady& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorRunningMsg_NotReady* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorRunningMsg_NotReady* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorRunningMsg_NotReady* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorRunningMsg_NotReady>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SensorRunningMsg_NotReady& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SensorRunningMsg_NotReady& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.SensorRunningMsg.NotReady";
  }
  protected:
  explicit SensorRunningMsg_NotReady(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:IntelliSwing.SensorRunningMsg.NotReady)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingInterface_2eproto;
};
// -------------------------------------------------------------------

class SensorRunningMsg_ShortTriggered final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.SensorRunningMsg.ShortTriggered) */ {
 public:
  inline SensorRunningMsg_ShortTriggered() : SensorRunningMsg_ShortTriggered(nullptr) {}
  ~SensorRunningMsg_ShortTriggered() override;
  explicit constexpr SensorRunningMsg_ShortTriggered(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorRunningMsg_ShortTriggered(const SensorRunningMsg_ShortTriggered& from);
  SensorRunningMsg_ShortTriggered(SensorRunningMsg_ShortTriggered&& from) noexcept
    : SensorRunningMsg_ShortTriggered() {
    *this = ::std::move(from);
  }

  inline SensorRunningMsg_ShortTriggered& operator=(const SensorRunningMsg_ShortTriggered& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorRunningMsg_ShortTriggered& operator=(SensorRunningMsg_ShortTriggered&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorRunningMsg_ShortTriggered& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorRunningMsg_ShortTriggered* internal_default_instance() {
    return reinterpret_cast<const SensorRunningMsg_ShortTriggered*>(
               &_SensorRunningMsg_ShortTriggered_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SensorRunningMsg_ShortTriggered& a, SensorRunningMsg_ShortTriggered& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorRunningMsg_ShortTriggered* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorRunningMsg_ShortTriggered* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorRunningMsg_ShortTriggered* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorRunningMsg_ShortTriggered>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorRunningMsg_ShortTriggered& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SensorRunningMsg_ShortTriggered& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorRunningMsg_ShortTriggered* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.SensorRunningMsg.ShortTriggered";
  }
  protected:
  explicit SensorRunningMsg_ShortTriggered(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 2,
    kShotIdFieldNumber = 1,
  };
  // uint64 timestamp = 2;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // int32 shotId = 1;
  void clear_shotid();
  int32_t shotid() const;
  void set_shotid(int32_t value);
  private:
  int32_t _internal_shotid() const;
  void _internal_set_shotid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:IntelliSwing.SensorRunningMsg.ShortTriggered)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t timestamp_;
  int32_t shotid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingInterface_2eproto;
};
// -------------------------------------------------------------------

class SensorRunningMsg_BallFlightInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.SensorRunningMsg.BallFlightInfo) */ {
 public:
  inline SensorRunningMsg_BallFlightInfo() : SensorRunningMsg_BallFlightInfo(nullptr) {}
  ~SensorRunningMsg_BallFlightInfo() override;
  explicit constexpr SensorRunningMsg_BallFlightInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorRunningMsg_BallFlightInfo(const SensorRunningMsg_BallFlightInfo& from);
  SensorRunningMsg_BallFlightInfo(SensorRunningMsg_BallFlightInfo&& from) noexcept
    : SensorRunningMsg_BallFlightInfo() {
    *this = ::std::move(from);
  }

  inline SensorRunningMsg_BallFlightInfo& operator=(const SensorRunningMsg_BallFlightInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorRunningMsg_BallFlightInfo& operator=(SensorRunningMsg_BallFlightInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorRunningMsg_BallFlightInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorRunningMsg_BallFlightInfo* internal_default_instance() {
    return reinterpret_cast<const SensorRunningMsg_BallFlightInfo*>(
               &_SensorRunningMsg_BallFlightInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SensorRunningMsg_BallFlightInfo& a, SensorRunningMsg_BallFlightInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorRunningMsg_BallFlightInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorRunningMsg_BallFlightInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorRunningMsg_BallFlightInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorRunningMsg_BallFlightInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorRunningMsg_BallFlightInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SensorRunningMsg_BallFlightInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorRunningMsg_BallFlightInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.SensorRunningMsg.BallFlightInfo";
  }
  protected:
  explicit SensorRunningMsg_BallFlightInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShotIdFieldNumber = 1,
    kBallSpeedFieldNumber = 2,
    kLunchAngleFieldNumber = 3,
    kDirectionFieldNumber = 4,
    kBackSpinFieldNumber = 5,
    kSideSpinFieldNumber = 6,
  };
  // int32 shotId = 1;
  void clear_shotid();
  int32_t shotid() const;
  void set_shotid(int32_t value);
  private:
  int32_t _internal_shotid() const;
  void _internal_set_shotid(int32_t value);
  public:

  // float ballSpeed = 2;
  void clear_ballspeed();
  float ballspeed() const;
  void set_ballspeed(float value);
  private:
  float _internal_ballspeed() const;
  void _internal_set_ballspeed(float value);
  public:

  // float lunchAngle = 3;
  void clear_lunchangle();
  float lunchangle() const;
  void set_lunchangle(float value);
  private:
  float _internal_lunchangle() const;
  void _internal_set_lunchangle(float value);
  public:

  // float direction = 4;
  void clear_direction();
  float direction() const;
  void set_direction(float value);
  private:
  float _internal_direction() const;
  void _internal_set_direction(float value);
  public:

  // float backSpin = 5;
  void clear_backspin();
  float backspin() const;
  void set_backspin(float value);
  private:
  float _internal_backspin() const;
  void _internal_set_backspin(float value);
  public:

  // float sideSpin = 6;
  void clear_sidespin();
  float sidespin() const;
  void set_sidespin(float value);
  private:
  float _internal_sidespin() const;
  void _internal_set_sidespin(float value);
  public:

  // @@protoc_insertion_point(class_scope:IntelliSwing.SensorRunningMsg.BallFlightInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t shotid_;
  float ballspeed_;
  float lunchangle_;
  float direction_;
  float backspin_;
  float sidespin_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingInterface_2eproto;
};
// -------------------------------------------------------------------

class SensorRunningMsg_ClubPathInfo_ClubPath final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:IntelliSwing.SensorRunningMsg.ClubPathInfo.ClubPath) */ {
 public:
  inline SensorRunningMsg_ClubPathInfo_ClubPath() : SensorRunningMsg_ClubPathInfo_ClubPath(nullptr) {}
  explicit constexpr SensorRunningMsg_ClubPathInfo_ClubPath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorRunningMsg_ClubPathInfo_ClubPath(const SensorRunningMsg_ClubPathInfo_ClubPath& from);
  SensorRunningMsg_ClubPathInfo_ClubPath(SensorRunningMsg_ClubPathInfo_ClubPath&& from) noexcept
    : SensorRunningMsg_ClubPathInfo_ClubPath() {
    *this = ::std::move(from);
  }

  inline SensorRunningMsg_ClubPathInfo_ClubPath& operator=(const SensorRunningMsg_ClubPathInfo_ClubPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorRunningMsg_ClubPathInfo_ClubPath& operator=(SensorRunningMsg_ClubPathInfo_ClubPath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorRunningMsg_ClubPathInfo_ClubPath& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorRunningMsg_ClubPathInfo_ClubPath* internal_default_instance() {
    return reinterpret_cast<const SensorRunningMsg_ClubPathInfo_ClubPath*>(
               &_SensorRunningMsg_ClubPathInfo_ClubPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SensorRunningMsg_ClubPathInfo_ClubPath& a, SensorRunningMsg_ClubPathInfo_ClubPath& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorRunningMsg_ClubPathInfo_ClubPath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorRunningMsg_ClubPathInfo_ClubPath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorRunningMsg_ClubPathInfo_ClubPath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorRunningMsg_ClubPathInfo_ClubPath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SensorRunningMsg_ClubPathInfo_ClubPath& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SensorRunningMsg_ClubPathInfo_ClubPath& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.SensorRunningMsg.ClubPathInfo.ClubPath";
  }
  protected:
  explicit SensorRunningMsg_ClubPathInfo_ClubPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:IntelliSwing.SensorRunningMsg.ClubPathInfo.ClubPath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingInterface_2eproto;
};
// -------------------------------------------------------------------

class SensorRunningMsg_ClubPathInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.SensorRunningMsg.ClubPathInfo) */ {
 public:
  inline SensorRunningMsg_ClubPathInfo() : SensorRunningMsg_ClubPathInfo(nullptr) {}
  ~SensorRunningMsg_ClubPathInfo() override;
  explicit constexpr SensorRunningMsg_ClubPathInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorRunningMsg_ClubPathInfo(const SensorRunningMsg_ClubPathInfo& from);
  SensorRunningMsg_ClubPathInfo(SensorRunningMsg_ClubPathInfo&& from) noexcept
    : SensorRunningMsg_ClubPathInfo() {
    *this = ::std::move(from);
  }

  inline SensorRunningMsg_ClubPathInfo& operator=(const SensorRunningMsg_ClubPathInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorRunningMsg_ClubPathInfo& operator=(SensorRunningMsg_ClubPathInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorRunningMsg_ClubPathInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorRunningMsg_ClubPathInfo* internal_default_instance() {
    return reinterpret_cast<const SensorRunningMsg_ClubPathInfo*>(
               &_SensorRunningMsg_ClubPathInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SensorRunningMsg_ClubPathInfo& a, SensorRunningMsg_ClubPathInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorRunningMsg_ClubPathInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorRunningMsg_ClubPathInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorRunningMsg_ClubPathInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorRunningMsg_ClubPathInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorRunningMsg_ClubPathInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SensorRunningMsg_ClubPathInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorRunningMsg_ClubPathInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.SensorRunningMsg.ClubPathInfo";
  }
  protected:
  explicit SensorRunningMsg_ClubPathInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SensorRunningMsg_ClubPathInfo_ClubPath ClubPath;

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 3,
    kShotIdFieldNumber = 1,
    kHeadSpeedFieldNumber = 2,
    kFaceAngleFieldNumber = 4,
    kAttackAngleFieldNumber = 5,
  };
  // .IntelliSwing.SensorRunningMsg.ClubPathInfo.ClubPath path = 3;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath& path() const;
  PROTOBUF_NODISCARD ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath* release_path();
  ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath* mutable_path();
  void set_allocated_path(::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath* path);
  private:
  const ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath& _internal_path() const;
  ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath* _internal_mutable_path();
  public:
  void unsafe_arena_set_allocated_path(
      ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath* path);
  ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath* unsafe_arena_release_path();

  // int32 shotId = 1;
  void clear_shotid();
  int32_t shotid() const;
  void set_shotid(int32_t value);
  private:
  int32_t _internal_shotid() const;
  void _internal_set_shotid(int32_t value);
  public:

  // float headSpeed = 2;
  void clear_headspeed();
  float headspeed() const;
  void set_headspeed(float value);
  private:
  float _internal_headspeed() const;
  void _internal_set_headspeed(float value);
  public:

  // float faceAngle = 4;
  void clear_faceangle();
  float faceangle() const;
  void set_faceangle(float value);
  private:
  float _internal_faceangle() const;
  void _internal_set_faceangle(float value);
  public:

  // float attackAngle = 5;
  void clear_attackangle();
  float attackangle() const;
  void set_attackangle(float value);
  private:
  float _internal_attackangle() const;
  void _internal_set_attackangle(float value);
  public:

  // @@protoc_insertion_point(class_scope:IntelliSwing.SensorRunningMsg.ClubPathInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath* path_;
  int32_t shotid_;
  float headspeed_;
  float faceangle_;
  float attackangle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingInterface_2eproto;
};
// -------------------------------------------------------------------

class SensorRunningMsg_Heartbeat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.SensorRunningMsg.Heartbeat) */ {
 public:
  inline SensorRunningMsg_Heartbeat() : SensorRunningMsg_Heartbeat(nullptr) {}
  ~SensorRunningMsg_Heartbeat() override;
  explicit constexpr SensorRunningMsg_Heartbeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorRunningMsg_Heartbeat(const SensorRunningMsg_Heartbeat& from);
  SensorRunningMsg_Heartbeat(SensorRunningMsg_Heartbeat&& from) noexcept
    : SensorRunningMsg_Heartbeat() {
    *this = ::std::move(from);
  }

  inline SensorRunningMsg_Heartbeat& operator=(const SensorRunningMsg_Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorRunningMsg_Heartbeat& operator=(SensorRunningMsg_Heartbeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorRunningMsg_Heartbeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorRunningMsg_Heartbeat* internal_default_instance() {
    return reinterpret_cast<const SensorRunningMsg_Heartbeat*>(
               &_SensorRunningMsg_Heartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SensorRunningMsg_Heartbeat& a, SensorRunningMsg_Heartbeat& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorRunningMsg_Heartbeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorRunningMsg_Heartbeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorRunningMsg_Heartbeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorRunningMsg_Heartbeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorRunningMsg_Heartbeat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SensorRunningMsg_Heartbeat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorRunningMsg_Heartbeat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.SensorRunningMsg.Heartbeat";
  }
  protected:
  explicit SensorRunningMsg_Heartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:IntelliSwing.SensorRunningMsg.Heartbeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingInterface_2eproto;
};
// -------------------------------------------------------------------

class SensorRunningMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.SensorRunningMsg) */ {
 public:
  inline SensorRunningMsg() : SensorRunningMsg(nullptr) {}
  ~SensorRunningMsg() override;
  explicit constexpr SensorRunningMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorRunningMsg(const SensorRunningMsg& from);
  SensorRunningMsg(SensorRunningMsg&& from) noexcept
    : SensorRunningMsg() {
    *this = ::std::move(from);
  }

  inline SensorRunningMsg& operator=(const SensorRunningMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorRunningMsg& operator=(SensorRunningMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorRunningMsg& default_instance() {
    return *internal_default_instance();
  }
  enum RunStateCase {
    kReady = 2,
    kNotReady = 3,
    kShotTriggered = 4,
    kBallInfo = 5,
    kClubInfo = 6,
    kHeartBeat = 7,
    RUNSTATE_NOT_SET = 0,
  };

  static inline const SensorRunningMsg* internal_default_instance() {
    return reinterpret_cast<const SensorRunningMsg*>(
               &_SensorRunningMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SensorRunningMsg& a, SensorRunningMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorRunningMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorRunningMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorRunningMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorRunningMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorRunningMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SensorRunningMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorRunningMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.SensorRunningMsg";
  }
  protected:
  explicit SensorRunningMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SensorRunningMsg_Ready Ready;
  typedef SensorRunningMsg_NotReady NotReady;
  typedef SensorRunningMsg_ShortTriggered ShortTriggered;
  typedef SensorRunningMsg_BallFlightInfo BallFlightInfo;
  typedef SensorRunningMsg_ClubPathInfo ClubPathInfo;
  typedef SensorRunningMsg_Heartbeat Heartbeat;

  // accessors -------------------------------------------------------

  enum : int {
    kTimeStampFieldNumber = 1,
    kReadyFieldNumber = 2,
    kNotReadyFieldNumber = 3,
    kShotTriggeredFieldNumber = 4,
    kBallInfoFieldNumber = 5,
    kClubInfoFieldNumber = 6,
    kHeartBeatFieldNumber = 7,
  };
  // .google.protobuf.Timestamp timeStamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_timestamp();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_timestamp() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_timestamp();

  // .IntelliSwing.SensorRunningMsg.Ready ready = 2;
  bool has_ready() const;
  private:
  bool _internal_has_ready() const;
  public:
  void clear_ready();
  const ::IntelliSwing::SensorRunningMsg_Ready& ready() const;
  PROTOBUF_NODISCARD ::IntelliSwing::SensorRunningMsg_Ready* release_ready();
  ::IntelliSwing::SensorRunningMsg_Ready* mutable_ready();
  void set_allocated_ready(::IntelliSwing::SensorRunningMsg_Ready* ready);
  private:
  const ::IntelliSwing::SensorRunningMsg_Ready& _internal_ready() const;
  ::IntelliSwing::SensorRunningMsg_Ready* _internal_mutable_ready();
  public:
  void unsafe_arena_set_allocated_ready(
      ::IntelliSwing::SensorRunningMsg_Ready* ready);
  ::IntelliSwing::SensorRunningMsg_Ready* unsafe_arena_release_ready();

  // .IntelliSwing.SensorRunningMsg.NotReady notReady = 3;
  bool has_notready() const;
  private:
  bool _internal_has_notready() const;
  public:
  void clear_notready();
  const ::IntelliSwing::SensorRunningMsg_NotReady& notready() const;
  PROTOBUF_NODISCARD ::IntelliSwing::SensorRunningMsg_NotReady* release_notready();
  ::IntelliSwing::SensorRunningMsg_NotReady* mutable_notready();
  void set_allocated_notready(::IntelliSwing::SensorRunningMsg_NotReady* notready);
  private:
  const ::IntelliSwing::SensorRunningMsg_NotReady& _internal_notready() const;
  ::IntelliSwing::SensorRunningMsg_NotReady* _internal_mutable_notready();
  public:
  void unsafe_arena_set_allocated_notready(
      ::IntelliSwing::SensorRunningMsg_NotReady* notready);
  ::IntelliSwing::SensorRunningMsg_NotReady* unsafe_arena_release_notready();

  // .IntelliSwing.SensorRunningMsg.ShortTriggered shotTriggered = 4;
  bool has_shottriggered() const;
  private:
  bool _internal_has_shottriggered() const;
  public:
  void clear_shottriggered();
  const ::IntelliSwing::SensorRunningMsg_ShortTriggered& shottriggered() const;
  PROTOBUF_NODISCARD ::IntelliSwing::SensorRunningMsg_ShortTriggered* release_shottriggered();
  ::IntelliSwing::SensorRunningMsg_ShortTriggered* mutable_shottriggered();
  void set_allocated_shottriggered(::IntelliSwing::SensorRunningMsg_ShortTriggered* shottriggered);
  private:
  const ::IntelliSwing::SensorRunningMsg_ShortTriggered& _internal_shottriggered() const;
  ::IntelliSwing::SensorRunningMsg_ShortTriggered* _internal_mutable_shottriggered();
  public:
  void unsafe_arena_set_allocated_shottriggered(
      ::IntelliSwing::SensorRunningMsg_ShortTriggered* shottriggered);
  ::IntelliSwing::SensorRunningMsg_ShortTriggered* unsafe_arena_release_shottriggered();

  // .IntelliSwing.SensorRunningMsg.BallFlightInfo ballInfo = 5;
  bool has_ballinfo() const;
  private:
  bool _internal_has_ballinfo() const;
  public:
  void clear_ballinfo();
  const ::IntelliSwing::SensorRunningMsg_BallFlightInfo& ballinfo() const;
  PROTOBUF_NODISCARD ::IntelliSwing::SensorRunningMsg_BallFlightInfo* release_ballinfo();
  ::IntelliSwing::SensorRunningMsg_BallFlightInfo* mutable_ballinfo();
  void set_allocated_ballinfo(::IntelliSwing::SensorRunningMsg_BallFlightInfo* ballinfo);
  private:
  const ::IntelliSwing::SensorRunningMsg_BallFlightInfo& _internal_ballinfo() const;
  ::IntelliSwing::SensorRunningMsg_BallFlightInfo* _internal_mutable_ballinfo();
  public:
  void unsafe_arena_set_allocated_ballinfo(
      ::IntelliSwing::SensorRunningMsg_BallFlightInfo* ballinfo);
  ::IntelliSwing::SensorRunningMsg_BallFlightInfo* unsafe_arena_release_ballinfo();

  // .IntelliSwing.SensorRunningMsg.ClubPathInfo clubInfo = 6;
  bool has_clubinfo() const;
  private:
  bool _internal_has_clubinfo() const;
  public:
  void clear_clubinfo();
  const ::IntelliSwing::SensorRunningMsg_ClubPathInfo& clubinfo() const;
  PROTOBUF_NODISCARD ::IntelliSwing::SensorRunningMsg_ClubPathInfo* release_clubinfo();
  ::IntelliSwing::SensorRunningMsg_ClubPathInfo* mutable_clubinfo();
  void set_allocated_clubinfo(::IntelliSwing::SensorRunningMsg_ClubPathInfo* clubinfo);
  private:
  const ::IntelliSwing::SensorRunningMsg_ClubPathInfo& _internal_clubinfo() const;
  ::IntelliSwing::SensorRunningMsg_ClubPathInfo* _internal_mutable_clubinfo();
  public:
  void unsafe_arena_set_allocated_clubinfo(
      ::IntelliSwing::SensorRunningMsg_ClubPathInfo* clubinfo);
  ::IntelliSwing::SensorRunningMsg_ClubPathInfo* unsafe_arena_release_clubinfo();

  // .IntelliSwing.SensorRunningMsg.Heartbeat heartBeat = 7;
  bool has_heartbeat() const;
  private:
  bool _internal_has_heartbeat() const;
  public:
  void clear_heartbeat();
  const ::IntelliSwing::SensorRunningMsg_Heartbeat& heartbeat() const;
  PROTOBUF_NODISCARD ::IntelliSwing::SensorRunningMsg_Heartbeat* release_heartbeat();
  ::IntelliSwing::SensorRunningMsg_Heartbeat* mutable_heartbeat();
  void set_allocated_heartbeat(::IntelliSwing::SensorRunningMsg_Heartbeat* heartbeat);
  private:
  const ::IntelliSwing::SensorRunningMsg_Heartbeat& _internal_heartbeat() const;
  ::IntelliSwing::SensorRunningMsg_Heartbeat* _internal_mutable_heartbeat();
  public:
  void unsafe_arena_set_allocated_heartbeat(
      ::IntelliSwing::SensorRunningMsg_Heartbeat* heartbeat);
  ::IntelliSwing::SensorRunningMsg_Heartbeat* unsafe_arena_release_heartbeat();

  void clear_runState();
  RunStateCase runState_case() const;
  // @@protoc_insertion_point(class_scope:IntelliSwing.SensorRunningMsg)
 private:
  class _Internal;
  void set_has_ready();
  void set_has_notready();
  void set_has_shottriggered();
  void set_has_ballinfo();
  void set_has_clubinfo();
  void set_has_heartbeat();

  inline bool has_runState() const;
  inline void clear_has_runState();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp_;
  union RunStateUnion {
    constexpr RunStateUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::IntelliSwing::SensorRunningMsg_Ready* ready_;
    ::IntelliSwing::SensorRunningMsg_NotReady* notready_;
    ::IntelliSwing::SensorRunningMsg_ShortTriggered* shottriggered_;
    ::IntelliSwing::SensorRunningMsg_BallFlightInfo* ballinfo_;
    ::IntelliSwing::SensorRunningMsg_ClubPathInfo* clubinfo_;
    ::IntelliSwing::SensorRunningMsg_Heartbeat* heartbeat_;
  } runState_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_IntelliSwingInterface_2eproto;
};
// -------------------------------------------------------------------

class ShotImageRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.ShotImageRequest) */ {
 public:
  inline ShotImageRequest() : ShotImageRequest(nullptr) {}
  ~ShotImageRequest() override;
  explicit constexpr ShotImageRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShotImageRequest(const ShotImageRequest& from);
  ShotImageRequest(ShotImageRequest&& from) noexcept
    : ShotImageRequest() {
    *this = ::std::move(from);
  }

  inline ShotImageRequest& operator=(const ShotImageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShotImageRequest& operator=(ShotImageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShotImageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShotImageRequest* internal_default_instance() {
    return reinterpret_cast<const ShotImageRequest*>(
               &_ShotImageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ShotImageRequest& a, ShotImageRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ShotImageRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShotImageRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShotImageRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShotImageRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShotImageRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShotImageRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShotImageRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.ShotImageRequest";
  }
  protected:
  explicit ShotImageRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShotIdFieldNumber = 1,
  };
  // int32 shotId = 1;
  void clear_shotid();
  int32_t shotid() const;
  void set_shotid(int32_t value);
  private:
  int32_t _internal_shotid() const;
  void _internal_set_shotid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:IntelliSwing.ShotImageRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t shotid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingInterface_2eproto;
};
// -------------------------------------------------------------------

class ImageData_Image_Marker final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.ImageData.Image.Marker) */ {
 public:
  inline ImageData_Image_Marker() : ImageData_Image_Marker(nullptr) {}
  ~ImageData_Image_Marker() override;
  explicit constexpr ImageData_Image_Marker(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageData_Image_Marker(const ImageData_Image_Marker& from);
  ImageData_Image_Marker(ImageData_Image_Marker&& from) noexcept
    : ImageData_Image_Marker() {
    *this = ::std::move(from);
  }

  inline ImageData_Image_Marker& operator=(const ImageData_Image_Marker& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageData_Image_Marker& operator=(ImageData_Image_Marker&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageData_Image_Marker& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageData_Image_Marker* internal_default_instance() {
    return reinterpret_cast<const ImageData_Image_Marker*>(
               &_ImageData_Image_Marker_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ImageData_Image_Marker& a, ImageData_Image_Marker& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageData_Image_Marker* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageData_Image_Marker* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageData_Image_Marker* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageData_Image_Marker>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageData_Image_Marker& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ImageData_Image_Marker& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageData_Image_Marker* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.ImageData.Image.Marker";
  }
  protected:
  explicit ImageData_Image_Marker(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 2,
    kPositionFieldNumber = 1,
  };
  // string tag = 2;
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // .IntelliSwing.Point2i position = 1;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::IntelliSwing::Point2i& position() const;
  PROTOBUF_NODISCARD ::IntelliSwing::Point2i* release_position();
  ::IntelliSwing::Point2i* mutable_position();
  void set_allocated_position(::IntelliSwing::Point2i* position);
  private:
  const ::IntelliSwing::Point2i& _internal_position() const;
  ::IntelliSwing::Point2i* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::IntelliSwing::Point2i* position);
  ::IntelliSwing::Point2i* unsafe_arena_release_position();

  // @@protoc_insertion_point(class_scope:IntelliSwing.ImageData.Image.Marker)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::IntelliSwing::Point2i* position_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingInterface_2eproto;
};
// -------------------------------------------------------------------

class ImageData_Image final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.ImageData.Image) */ {
 public:
  inline ImageData_Image() : ImageData_Image(nullptr) {}
  ~ImageData_Image() override;
  explicit constexpr ImageData_Image(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageData_Image(const ImageData_Image& from);
  ImageData_Image(ImageData_Image&& from) noexcept
    : ImageData_Image() {
    *this = ::std::move(from);
  }

  inline ImageData_Image& operator=(const ImageData_Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageData_Image& operator=(ImageData_Image&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageData_Image& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageData_Image* internal_default_instance() {
    return reinterpret_cast<const ImageData_Image*>(
               &_ImageData_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ImageData_Image& a, ImageData_Image& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageData_Image* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageData_Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageData_Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageData_Image>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageData_Image& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ImageData_Image& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageData_Image* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.ImageData.Image";
  }
  protected:
  explicit ImageData_Image(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ImageData_Image_Marker Marker;

  // accessors -------------------------------------------------------

  enum : int {
    kMarkersFieldNumber = 8,
    kDataFieldNumber = 2,
    kTagFieldNumber = 7,
    kImageTypeFieldNumber = 1,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
    kChannelFieldNumber = 5,
    kDataTypeFieldNumber = 6,
  };
  // repeated .IntelliSwing.ImageData.Image.Marker markers = 8;
  int markers_size() const;
  private:
  int _internal_markers_size() const;
  public:
  void clear_markers();
  ::IntelliSwing::ImageData_Image_Marker* mutable_markers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntelliSwing::ImageData_Image_Marker >*
      mutable_markers();
  private:
  const ::IntelliSwing::ImageData_Image_Marker& _internal_markers(int index) const;
  ::IntelliSwing::ImageData_Image_Marker* _internal_add_markers();
  public:
  const ::IntelliSwing::ImageData_Image_Marker& markers(int index) const;
  ::IntelliSwing::ImageData_Image_Marker* add_markers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntelliSwing::ImageData_Image_Marker >&
      markers() const;

  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string tag = 7;
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // int32 imageType = 1;
  void clear_imagetype();
  int32_t imagetype() const;
  void set_imagetype(int32_t value);
  private:
  int32_t _internal_imagetype() const;
  void _internal_set_imagetype(int32_t value);
  public:

  // int32 width = 3;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // int32 height = 4;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // int32 channel = 5;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // int32 dataType = 6;
  void clear_datatype();
  int32_t datatype() const;
  void set_datatype(int32_t value);
  private:
  int32_t _internal_datatype() const;
  void _internal_set_datatype(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:IntelliSwing.ImageData.Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntelliSwing::ImageData_Image_Marker > markers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  int32_t imagetype_;
  int32_t width_;
  int32_t height_;
  int32_t channel_;
  int32_t datatype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingInterface_2eproto;
};
// -------------------------------------------------------------------

class ImageData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.ImageData) */ {
 public:
  inline ImageData() : ImageData(nullptr) {}
  ~ImageData() override;
  explicit constexpr ImageData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImageData(const ImageData& from);
  ImageData(ImageData&& from) noexcept
    : ImageData() {
    *this = ::std::move(from);
  }

  inline ImageData& operator=(const ImageData& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageData& operator=(ImageData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageData& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageData* internal_default_instance() {
    return reinterpret_cast<const ImageData*>(
               &_ImageData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ImageData& a, ImageData& b) {
    a.Swap(&b);
  }
  inline void Swap(ImageData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImageData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImageData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ImageData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImageData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.ImageData";
  }
  protected:
  explicit ImageData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ImageData_Image Image;

  // accessors -------------------------------------------------------

  enum : int {
    kImagesFieldNumber = 2,
    kStateFieldNumber = 1,
  };
  // repeated .IntelliSwing.ImageData.Image images = 2;
  int images_size() const;
  private:
  int _internal_images_size() const;
  public:
  void clear_images();
  ::IntelliSwing::ImageData_Image* mutable_images(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntelliSwing::ImageData_Image >*
      mutable_images();
  private:
  const ::IntelliSwing::ImageData_Image& _internal_images(int index) const;
  ::IntelliSwing::ImageData_Image* _internal_add_images();
  public:
  const ::IntelliSwing::ImageData_Image& images(int index) const;
  ::IntelliSwing::ImageData_Image* add_images();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntelliSwing::ImageData_Image >&
      images() const;

  // .IntelliSwing.ReturnMsg state = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::IntelliSwing::ReturnMsg& state() const;
  PROTOBUF_NODISCARD ::IntelliSwing::ReturnMsg* release_state();
  ::IntelliSwing::ReturnMsg* mutable_state();
  void set_allocated_state(::IntelliSwing::ReturnMsg* state);
  private:
  const ::IntelliSwing::ReturnMsg& _internal_state() const;
  ::IntelliSwing::ReturnMsg* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::IntelliSwing::ReturnMsg* state);
  ::IntelliSwing::ReturnMsg* unsafe_arena_release_state();

  // @@protoc_insertion_point(class_scope:IntelliSwing.ImageData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntelliSwing::ImageData_Image > images_;
  ::IntelliSwing::ReturnMsg* state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingInterface_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InitializeMsg

// .IntelliSwing.InitializeMsg.Client client = 4;
inline void InitializeMsg::clear_client() {
  client_ = 0;
}
inline ::IntelliSwing::InitializeMsg_Client InitializeMsg::_internal_client() const {
  return static_cast< ::IntelliSwing::InitializeMsg_Client >(client_);
}
inline ::IntelliSwing::InitializeMsg_Client InitializeMsg::client() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.InitializeMsg.client)
  return _internal_client();
}
inline void InitializeMsg::_internal_set_client(::IntelliSwing::InitializeMsg_Client value) {
  
  client_ = value;
}
inline void InitializeMsg::set_client(::IntelliSwing::InitializeMsg_Client value) {
  _internal_set_client(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.InitializeMsg.client)
}

// -------------------------------------------------------------------

// ReleaseMsg

// int32 id = 1;
inline void ReleaseMsg::clear_id() {
  id_ = 0;
}
inline int32_t ReleaseMsg::_internal_id() const {
  return id_;
}
inline int32_t ReleaseMsg::id() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.ReleaseMsg.id)
  return _internal_id();
}
inline void ReleaseMsg::_internal_set_id(int32_t value) {
  
  id_ = value;
}
inline void ReleaseMsg::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.ReleaseMsg.id)
}

// -------------------------------------------------------------------

// StartMsg

// .IntelliSwing.StartMsg.ClubInformation clubInformation = 1;
inline void StartMsg::clear_clubinformation() {
  clubinformation_ = 0;
}
inline ::IntelliSwing::StartMsg_ClubInformation StartMsg::_internal_clubinformation() const {
  return static_cast< ::IntelliSwing::StartMsg_ClubInformation >(clubinformation_);
}
inline ::IntelliSwing::StartMsg_ClubInformation StartMsg::clubinformation() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.StartMsg.clubInformation)
  return _internal_clubinformation();
}
inline void StartMsg::_internal_set_clubinformation(::IntelliSwing::StartMsg_ClubInformation value) {
  
  clubinformation_ = value;
}
inline void StartMsg::set_clubinformation(::IntelliSwing::StartMsg_ClubInformation value) {
  _internal_set_clubinformation(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.StartMsg.clubInformation)
}

// -------------------------------------------------------------------

// SensorRunningMsg_Ready

// .IntelliSwing.Point3f position = 1;
inline bool SensorRunningMsg_Ready::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool SensorRunningMsg_Ready::has_position() const {
  return _internal_has_position();
}
inline const ::IntelliSwing::Point3f& SensorRunningMsg_Ready::_internal_position() const {
  const ::IntelliSwing::Point3f* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::IntelliSwing::Point3f&>(
      ::IntelliSwing::_Point3f_default_instance_);
}
inline const ::IntelliSwing::Point3f& SensorRunningMsg_Ready::position() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.Ready.position)
  return _internal_position();
}
inline void SensorRunningMsg_Ready::unsafe_arena_set_allocated_position(
    ::IntelliSwing::Point3f* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IntelliSwing.SensorRunningMsg.Ready.position)
}
inline ::IntelliSwing::Point3f* SensorRunningMsg_Ready::release_position() {
  
  ::IntelliSwing::Point3f* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::IntelliSwing::Point3f* SensorRunningMsg_Ready::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:IntelliSwing.SensorRunningMsg.Ready.position)
  
  ::IntelliSwing::Point3f* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::IntelliSwing::Point3f* SensorRunningMsg_Ready::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::IntelliSwing::Point3f>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::IntelliSwing::Point3f* SensorRunningMsg_Ready::mutable_position() {
  ::IntelliSwing::Point3f* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.SensorRunningMsg.Ready.position)
  return _msg;
}
inline void SensorRunningMsg_Ready::set_allocated_position(::IntelliSwing::Point3f* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:IntelliSwing.SensorRunningMsg.Ready.position)
}

// bool isTee = 2;
inline void SensorRunningMsg_Ready::clear_istee() {
  istee_ = false;
}
inline bool SensorRunningMsg_Ready::_internal_istee() const {
  return istee_;
}
inline bool SensorRunningMsg_Ready::istee() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.Ready.isTee)
  return _internal_istee();
}
inline void SensorRunningMsg_Ready::_internal_set_istee(bool value) {
  
  istee_ = value;
}
inline void SensorRunningMsg_Ready::set_istee(bool value) {
  _internal_set_istee(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.SensorRunningMsg.Ready.isTee)
}

// -------------------------------------------------------------------

// SensorRunningMsg_NotReady

// -------------------------------------------------------------------

// SensorRunningMsg_ShortTriggered

// int32 shotId = 1;
inline void SensorRunningMsg_ShortTriggered::clear_shotid() {
  shotid_ = 0;
}
inline int32_t SensorRunningMsg_ShortTriggered::_internal_shotid() const {
  return shotid_;
}
inline int32_t SensorRunningMsg_ShortTriggered::shotid() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.ShortTriggered.shotId)
  return _internal_shotid();
}
inline void SensorRunningMsg_ShortTriggered::_internal_set_shotid(int32_t value) {
  
  shotid_ = value;
}
inline void SensorRunningMsg_ShortTriggered::set_shotid(int32_t value) {
  _internal_set_shotid(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.SensorRunningMsg.ShortTriggered.shotId)
}

// uint64 timestamp = 2;
inline void SensorRunningMsg_ShortTriggered::clear_timestamp() {
  timestamp_ = uint64_t{0u};
}
inline uint64_t SensorRunningMsg_ShortTriggered::_internal_timestamp() const {
  return timestamp_;
}
inline uint64_t SensorRunningMsg_ShortTriggered::timestamp() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.ShortTriggered.timestamp)
  return _internal_timestamp();
}
inline void SensorRunningMsg_ShortTriggered::_internal_set_timestamp(uint64_t value) {
  
  timestamp_ = value;
}
inline void SensorRunningMsg_ShortTriggered::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.SensorRunningMsg.ShortTriggered.timestamp)
}

// -------------------------------------------------------------------

// SensorRunningMsg_BallFlightInfo

// int32 shotId = 1;
inline void SensorRunningMsg_BallFlightInfo::clear_shotid() {
  shotid_ = 0;
}
inline int32_t SensorRunningMsg_BallFlightInfo::_internal_shotid() const {
  return shotid_;
}
inline int32_t SensorRunningMsg_BallFlightInfo::shotid() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.BallFlightInfo.shotId)
  return _internal_shotid();
}
inline void SensorRunningMsg_BallFlightInfo::_internal_set_shotid(int32_t value) {
  
  shotid_ = value;
}
inline void SensorRunningMsg_BallFlightInfo::set_shotid(int32_t value) {
  _internal_set_shotid(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.SensorRunningMsg.BallFlightInfo.shotId)
}

// float ballSpeed = 2;
inline void SensorRunningMsg_BallFlightInfo::clear_ballspeed() {
  ballspeed_ = 0;
}
inline float SensorRunningMsg_BallFlightInfo::_internal_ballspeed() const {
  return ballspeed_;
}
inline float SensorRunningMsg_BallFlightInfo::ballspeed() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.BallFlightInfo.ballSpeed)
  return _internal_ballspeed();
}
inline void SensorRunningMsg_BallFlightInfo::_internal_set_ballspeed(float value) {
  
  ballspeed_ = value;
}
inline void SensorRunningMsg_BallFlightInfo::set_ballspeed(float value) {
  _internal_set_ballspeed(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.SensorRunningMsg.BallFlightInfo.ballSpeed)
}

// float lunchAngle = 3;
inline void SensorRunningMsg_BallFlightInfo::clear_lunchangle() {
  lunchangle_ = 0;
}
inline float SensorRunningMsg_BallFlightInfo::_internal_lunchangle() const {
  return lunchangle_;
}
inline float SensorRunningMsg_BallFlightInfo::lunchangle() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.BallFlightInfo.lunchAngle)
  return _internal_lunchangle();
}
inline void SensorRunningMsg_BallFlightInfo::_internal_set_lunchangle(float value) {
  
  lunchangle_ = value;
}
inline void SensorRunningMsg_BallFlightInfo::set_lunchangle(float value) {
  _internal_set_lunchangle(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.SensorRunningMsg.BallFlightInfo.lunchAngle)
}

// float direction = 4;
inline void SensorRunningMsg_BallFlightInfo::clear_direction() {
  direction_ = 0;
}
inline float SensorRunningMsg_BallFlightInfo::_internal_direction() const {
  return direction_;
}
inline float SensorRunningMsg_BallFlightInfo::direction() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.BallFlightInfo.direction)
  return _internal_direction();
}
inline void SensorRunningMsg_BallFlightInfo::_internal_set_direction(float value) {
  
  direction_ = value;
}
inline void SensorRunningMsg_BallFlightInfo::set_direction(float value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.SensorRunningMsg.BallFlightInfo.direction)
}

// float backSpin = 5;
inline void SensorRunningMsg_BallFlightInfo::clear_backspin() {
  backspin_ = 0;
}
inline float SensorRunningMsg_BallFlightInfo::_internal_backspin() const {
  return backspin_;
}
inline float SensorRunningMsg_BallFlightInfo::backspin() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.BallFlightInfo.backSpin)
  return _internal_backspin();
}
inline void SensorRunningMsg_BallFlightInfo::_internal_set_backspin(float value) {
  
  backspin_ = value;
}
inline void SensorRunningMsg_BallFlightInfo::set_backspin(float value) {
  _internal_set_backspin(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.SensorRunningMsg.BallFlightInfo.backSpin)
}

// float sideSpin = 6;
inline void SensorRunningMsg_BallFlightInfo::clear_sidespin() {
  sidespin_ = 0;
}
inline float SensorRunningMsg_BallFlightInfo::_internal_sidespin() const {
  return sidespin_;
}
inline float SensorRunningMsg_BallFlightInfo::sidespin() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.BallFlightInfo.sideSpin)
  return _internal_sidespin();
}
inline void SensorRunningMsg_BallFlightInfo::_internal_set_sidespin(float value) {
  
  sidespin_ = value;
}
inline void SensorRunningMsg_BallFlightInfo::set_sidespin(float value) {
  _internal_set_sidespin(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.SensorRunningMsg.BallFlightInfo.sideSpin)
}

// -------------------------------------------------------------------

// SensorRunningMsg_ClubPathInfo_ClubPath

// -------------------------------------------------------------------

// SensorRunningMsg_ClubPathInfo

// int32 shotId = 1;
inline void SensorRunningMsg_ClubPathInfo::clear_shotid() {
  shotid_ = 0;
}
inline int32_t SensorRunningMsg_ClubPathInfo::_internal_shotid() const {
  return shotid_;
}
inline int32_t SensorRunningMsg_ClubPathInfo::shotid() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.ClubPathInfo.shotId)
  return _internal_shotid();
}
inline void SensorRunningMsg_ClubPathInfo::_internal_set_shotid(int32_t value) {
  
  shotid_ = value;
}
inline void SensorRunningMsg_ClubPathInfo::set_shotid(int32_t value) {
  _internal_set_shotid(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.SensorRunningMsg.ClubPathInfo.shotId)
}

// float headSpeed = 2;
inline void SensorRunningMsg_ClubPathInfo::clear_headspeed() {
  headspeed_ = 0;
}
inline float SensorRunningMsg_ClubPathInfo::_internal_headspeed() const {
  return headspeed_;
}
inline float SensorRunningMsg_ClubPathInfo::headspeed() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.ClubPathInfo.headSpeed)
  return _internal_headspeed();
}
inline void SensorRunningMsg_ClubPathInfo::_internal_set_headspeed(float value) {
  
  headspeed_ = value;
}
inline void SensorRunningMsg_ClubPathInfo::set_headspeed(float value) {
  _internal_set_headspeed(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.SensorRunningMsg.ClubPathInfo.headSpeed)
}

// .IntelliSwing.SensorRunningMsg.ClubPathInfo.ClubPath path = 3;
inline bool SensorRunningMsg_ClubPathInfo::_internal_has_path() const {
  return this != internal_default_instance() && path_ != nullptr;
}
inline bool SensorRunningMsg_ClubPathInfo::has_path() const {
  return _internal_has_path();
}
inline void SensorRunningMsg_ClubPathInfo::clear_path() {
  if (GetArenaForAllocation() == nullptr && path_ != nullptr) {
    delete path_;
  }
  path_ = nullptr;
}
inline const ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath& SensorRunningMsg_ClubPathInfo::_internal_path() const {
  const ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath* p = path_;
  return p != nullptr ? *p : reinterpret_cast<const ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath&>(
      ::IntelliSwing::_SensorRunningMsg_ClubPathInfo_ClubPath_default_instance_);
}
inline const ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath& SensorRunningMsg_ClubPathInfo::path() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.ClubPathInfo.path)
  return _internal_path();
}
inline void SensorRunningMsg_ClubPathInfo::unsafe_arena_set_allocated_path(
    ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath* path) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(path_);
  }
  path_ = path;
  if (path) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IntelliSwing.SensorRunningMsg.ClubPathInfo.path)
}
inline ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath* SensorRunningMsg_ClubPathInfo::release_path() {
  
  ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath* temp = path_;
  path_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath* SensorRunningMsg_ClubPathInfo::unsafe_arena_release_path() {
  // @@protoc_insertion_point(field_release:IntelliSwing.SensorRunningMsg.ClubPathInfo.path)
  
  ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath* temp = path_;
  path_ = nullptr;
  return temp;
}
inline ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath* SensorRunningMsg_ClubPathInfo::_internal_mutable_path() {
  
  if (path_ == nullptr) {
    auto* p = CreateMaybeMessage<::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath>(GetArenaForAllocation());
    path_ = p;
  }
  return path_;
}
inline ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath* SensorRunningMsg_ClubPathInfo::mutable_path() {
  ::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath* _msg = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.SensorRunningMsg.ClubPathInfo.path)
  return _msg;
}
inline void SensorRunningMsg_ClubPathInfo::set_allocated_path(::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath* path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete path_;
  }
  if (path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::IntelliSwing::SensorRunningMsg_ClubPathInfo_ClubPath>::GetOwningArena(path);
    if (message_arena != submessage_arena) {
      path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, path, submessage_arena);
    }
    
  } else {
    
  }
  path_ = path;
  // @@protoc_insertion_point(field_set_allocated:IntelliSwing.SensorRunningMsg.ClubPathInfo.path)
}

// float faceAngle = 4;
inline void SensorRunningMsg_ClubPathInfo::clear_faceangle() {
  faceangle_ = 0;
}
inline float SensorRunningMsg_ClubPathInfo::_internal_faceangle() const {
  return faceangle_;
}
inline float SensorRunningMsg_ClubPathInfo::faceangle() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.ClubPathInfo.faceAngle)
  return _internal_faceangle();
}
inline void SensorRunningMsg_ClubPathInfo::_internal_set_faceangle(float value) {
  
  faceangle_ = value;
}
inline void SensorRunningMsg_ClubPathInfo::set_faceangle(float value) {
  _internal_set_faceangle(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.SensorRunningMsg.ClubPathInfo.faceAngle)
}

// float attackAngle = 5;
inline void SensorRunningMsg_ClubPathInfo::clear_attackangle() {
  attackangle_ = 0;
}
inline float SensorRunningMsg_ClubPathInfo::_internal_attackangle() const {
  return attackangle_;
}
inline float SensorRunningMsg_ClubPathInfo::attackangle() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.ClubPathInfo.attackAngle)
  return _internal_attackangle();
}
inline void SensorRunningMsg_ClubPathInfo::_internal_set_attackangle(float value) {
  
  attackangle_ = value;
}
inline void SensorRunningMsg_ClubPathInfo::set_attackangle(float value) {
  _internal_set_attackangle(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.SensorRunningMsg.ClubPathInfo.attackAngle)
}

// -------------------------------------------------------------------

// SensorRunningMsg_Heartbeat

// string msg = 1;
inline void SensorRunningMsg_Heartbeat::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& SensorRunningMsg_Heartbeat::msg() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.Heartbeat.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorRunningMsg_Heartbeat::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IntelliSwing.SensorRunningMsg.Heartbeat.msg)
}
inline std::string* SensorRunningMsg_Heartbeat::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.SensorRunningMsg.Heartbeat.msg)
  return _s;
}
inline const std::string& SensorRunningMsg_Heartbeat::_internal_msg() const {
  return msg_.Get();
}
inline void SensorRunningMsg_Heartbeat::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SensorRunningMsg_Heartbeat::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SensorRunningMsg_Heartbeat::release_msg() {
  // @@protoc_insertion_point(field_release:IntelliSwing.SensorRunningMsg.Heartbeat.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SensorRunningMsg_Heartbeat::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IntelliSwing.SensorRunningMsg.Heartbeat.msg)
}

// -------------------------------------------------------------------

// SensorRunningMsg

// .google.protobuf.Timestamp timeStamp = 1;
inline bool SensorRunningMsg::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool SensorRunningMsg::has_timestamp() const {
  return _internal_has_timestamp();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SensorRunningMsg::_internal_timestamp() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& SensorRunningMsg::timestamp() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.timeStamp)
  return _internal_timestamp();
}
inline void SensorRunningMsg::unsafe_arena_set_allocated_timestamp(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IntelliSwing.SensorRunningMsg.timeStamp)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SensorRunningMsg::release_timestamp() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SensorRunningMsg::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:IntelliSwing.SensorRunningMsg.timeStamp)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SensorRunningMsg::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* SensorRunningMsg::mutable_timestamp() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.SensorRunningMsg.timeStamp)
  return _msg;
}
inline void SensorRunningMsg::set_allocated_timestamp(::PROTOBUF_NAMESPACE_ID::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:IntelliSwing.SensorRunningMsg.timeStamp)
}

// .IntelliSwing.SensorRunningMsg.Ready ready = 2;
inline bool SensorRunningMsg::_internal_has_ready() const {
  return runState_case() == kReady;
}
inline bool SensorRunningMsg::has_ready() const {
  return _internal_has_ready();
}
inline void SensorRunningMsg::set_has_ready() {
  _oneof_case_[0] = kReady;
}
inline void SensorRunningMsg::clear_ready() {
  if (_internal_has_ready()) {
    if (GetArenaForAllocation() == nullptr) {
      delete runState_.ready_;
    }
    clear_has_runState();
  }
}
inline ::IntelliSwing::SensorRunningMsg_Ready* SensorRunningMsg::release_ready() {
  // @@protoc_insertion_point(field_release:IntelliSwing.SensorRunningMsg.ready)
  if (_internal_has_ready()) {
    clear_has_runState();
      ::IntelliSwing::SensorRunningMsg_Ready* temp = runState_.ready_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    runState_.ready_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::IntelliSwing::SensorRunningMsg_Ready& SensorRunningMsg::_internal_ready() const {
  return _internal_has_ready()
      ? *runState_.ready_
      : reinterpret_cast< ::IntelliSwing::SensorRunningMsg_Ready&>(::IntelliSwing::_SensorRunningMsg_Ready_default_instance_);
}
inline const ::IntelliSwing::SensorRunningMsg_Ready& SensorRunningMsg::ready() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.ready)
  return _internal_ready();
}
inline ::IntelliSwing::SensorRunningMsg_Ready* SensorRunningMsg::unsafe_arena_release_ready() {
  // @@protoc_insertion_point(field_unsafe_arena_release:IntelliSwing.SensorRunningMsg.ready)
  if (_internal_has_ready()) {
    clear_has_runState();
    ::IntelliSwing::SensorRunningMsg_Ready* temp = runState_.ready_;
    runState_.ready_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorRunningMsg::unsafe_arena_set_allocated_ready(::IntelliSwing::SensorRunningMsg_Ready* ready) {
  clear_runState();
  if (ready) {
    set_has_ready();
    runState_.ready_ = ready;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IntelliSwing.SensorRunningMsg.ready)
}
inline ::IntelliSwing::SensorRunningMsg_Ready* SensorRunningMsg::_internal_mutable_ready() {
  if (!_internal_has_ready()) {
    clear_runState();
    set_has_ready();
    runState_.ready_ = CreateMaybeMessage< ::IntelliSwing::SensorRunningMsg_Ready >(GetArenaForAllocation());
  }
  return runState_.ready_;
}
inline ::IntelliSwing::SensorRunningMsg_Ready* SensorRunningMsg::mutable_ready() {
  ::IntelliSwing::SensorRunningMsg_Ready* _msg = _internal_mutable_ready();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.SensorRunningMsg.ready)
  return _msg;
}

// .IntelliSwing.SensorRunningMsg.NotReady notReady = 3;
inline bool SensorRunningMsg::_internal_has_notready() const {
  return runState_case() == kNotReady;
}
inline bool SensorRunningMsg::has_notready() const {
  return _internal_has_notready();
}
inline void SensorRunningMsg::set_has_notready() {
  _oneof_case_[0] = kNotReady;
}
inline void SensorRunningMsg::clear_notready() {
  if (_internal_has_notready()) {
    if (GetArenaForAllocation() == nullptr) {
      delete runState_.notready_;
    }
    clear_has_runState();
  }
}
inline ::IntelliSwing::SensorRunningMsg_NotReady* SensorRunningMsg::release_notready() {
  // @@protoc_insertion_point(field_release:IntelliSwing.SensorRunningMsg.notReady)
  if (_internal_has_notready()) {
    clear_has_runState();
      ::IntelliSwing::SensorRunningMsg_NotReady* temp = runState_.notready_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    runState_.notready_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::IntelliSwing::SensorRunningMsg_NotReady& SensorRunningMsg::_internal_notready() const {
  return _internal_has_notready()
      ? *runState_.notready_
      : reinterpret_cast< ::IntelliSwing::SensorRunningMsg_NotReady&>(::IntelliSwing::_SensorRunningMsg_NotReady_default_instance_);
}
inline const ::IntelliSwing::SensorRunningMsg_NotReady& SensorRunningMsg::notready() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.notReady)
  return _internal_notready();
}
inline ::IntelliSwing::SensorRunningMsg_NotReady* SensorRunningMsg::unsafe_arena_release_notready() {
  // @@protoc_insertion_point(field_unsafe_arena_release:IntelliSwing.SensorRunningMsg.notReady)
  if (_internal_has_notready()) {
    clear_has_runState();
    ::IntelliSwing::SensorRunningMsg_NotReady* temp = runState_.notready_;
    runState_.notready_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorRunningMsg::unsafe_arena_set_allocated_notready(::IntelliSwing::SensorRunningMsg_NotReady* notready) {
  clear_runState();
  if (notready) {
    set_has_notready();
    runState_.notready_ = notready;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IntelliSwing.SensorRunningMsg.notReady)
}
inline ::IntelliSwing::SensorRunningMsg_NotReady* SensorRunningMsg::_internal_mutable_notready() {
  if (!_internal_has_notready()) {
    clear_runState();
    set_has_notready();
    runState_.notready_ = CreateMaybeMessage< ::IntelliSwing::SensorRunningMsg_NotReady >(GetArenaForAllocation());
  }
  return runState_.notready_;
}
inline ::IntelliSwing::SensorRunningMsg_NotReady* SensorRunningMsg::mutable_notready() {
  ::IntelliSwing::SensorRunningMsg_NotReady* _msg = _internal_mutable_notready();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.SensorRunningMsg.notReady)
  return _msg;
}

// .IntelliSwing.SensorRunningMsg.ShortTriggered shotTriggered = 4;
inline bool SensorRunningMsg::_internal_has_shottriggered() const {
  return runState_case() == kShotTriggered;
}
inline bool SensorRunningMsg::has_shottriggered() const {
  return _internal_has_shottriggered();
}
inline void SensorRunningMsg::set_has_shottriggered() {
  _oneof_case_[0] = kShotTriggered;
}
inline void SensorRunningMsg::clear_shottriggered() {
  if (_internal_has_shottriggered()) {
    if (GetArenaForAllocation() == nullptr) {
      delete runState_.shottriggered_;
    }
    clear_has_runState();
  }
}
inline ::IntelliSwing::SensorRunningMsg_ShortTriggered* SensorRunningMsg::release_shottriggered() {
  // @@protoc_insertion_point(field_release:IntelliSwing.SensorRunningMsg.shotTriggered)
  if (_internal_has_shottriggered()) {
    clear_has_runState();
      ::IntelliSwing::SensorRunningMsg_ShortTriggered* temp = runState_.shottriggered_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    runState_.shottriggered_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::IntelliSwing::SensorRunningMsg_ShortTriggered& SensorRunningMsg::_internal_shottriggered() const {
  return _internal_has_shottriggered()
      ? *runState_.shottriggered_
      : reinterpret_cast< ::IntelliSwing::SensorRunningMsg_ShortTriggered&>(::IntelliSwing::_SensorRunningMsg_ShortTriggered_default_instance_);
}
inline const ::IntelliSwing::SensorRunningMsg_ShortTriggered& SensorRunningMsg::shottriggered() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.shotTriggered)
  return _internal_shottriggered();
}
inline ::IntelliSwing::SensorRunningMsg_ShortTriggered* SensorRunningMsg::unsafe_arena_release_shottriggered() {
  // @@protoc_insertion_point(field_unsafe_arena_release:IntelliSwing.SensorRunningMsg.shotTriggered)
  if (_internal_has_shottriggered()) {
    clear_has_runState();
    ::IntelliSwing::SensorRunningMsg_ShortTriggered* temp = runState_.shottriggered_;
    runState_.shottriggered_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorRunningMsg::unsafe_arena_set_allocated_shottriggered(::IntelliSwing::SensorRunningMsg_ShortTriggered* shottriggered) {
  clear_runState();
  if (shottriggered) {
    set_has_shottriggered();
    runState_.shottriggered_ = shottriggered;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IntelliSwing.SensorRunningMsg.shotTriggered)
}
inline ::IntelliSwing::SensorRunningMsg_ShortTriggered* SensorRunningMsg::_internal_mutable_shottriggered() {
  if (!_internal_has_shottriggered()) {
    clear_runState();
    set_has_shottriggered();
    runState_.shottriggered_ = CreateMaybeMessage< ::IntelliSwing::SensorRunningMsg_ShortTriggered >(GetArenaForAllocation());
  }
  return runState_.shottriggered_;
}
inline ::IntelliSwing::SensorRunningMsg_ShortTriggered* SensorRunningMsg::mutable_shottriggered() {
  ::IntelliSwing::SensorRunningMsg_ShortTriggered* _msg = _internal_mutable_shottriggered();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.SensorRunningMsg.shotTriggered)
  return _msg;
}

// .IntelliSwing.SensorRunningMsg.BallFlightInfo ballInfo = 5;
inline bool SensorRunningMsg::_internal_has_ballinfo() const {
  return runState_case() == kBallInfo;
}
inline bool SensorRunningMsg::has_ballinfo() const {
  return _internal_has_ballinfo();
}
inline void SensorRunningMsg::set_has_ballinfo() {
  _oneof_case_[0] = kBallInfo;
}
inline void SensorRunningMsg::clear_ballinfo() {
  if (_internal_has_ballinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete runState_.ballinfo_;
    }
    clear_has_runState();
  }
}
inline ::IntelliSwing::SensorRunningMsg_BallFlightInfo* SensorRunningMsg::release_ballinfo() {
  // @@protoc_insertion_point(field_release:IntelliSwing.SensorRunningMsg.ballInfo)
  if (_internal_has_ballinfo()) {
    clear_has_runState();
      ::IntelliSwing::SensorRunningMsg_BallFlightInfo* temp = runState_.ballinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    runState_.ballinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::IntelliSwing::SensorRunningMsg_BallFlightInfo& SensorRunningMsg::_internal_ballinfo() const {
  return _internal_has_ballinfo()
      ? *runState_.ballinfo_
      : reinterpret_cast< ::IntelliSwing::SensorRunningMsg_BallFlightInfo&>(::IntelliSwing::_SensorRunningMsg_BallFlightInfo_default_instance_);
}
inline const ::IntelliSwing::SensorRunningMsg_BallFlightInfo& SensorRunningMsg::ballinfo() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.ballInfo)
  return _internal_ballinfo();
}
inline ::IntelliSwing::SensorRunningMsg_BallFlightInfo* SensorRunningMsg::unsafe_arena_release_ballinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:IntelliSwing.SensorRunningMsg.ballInfo)
  if (_internal_has_ballinfo()) {
    clear_has_runState();
    ::IntelliSwing::SensorRunningMsg_BallFlightInfo* temp = runState_.ballinfo_;
    runState_.ballinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorRunningMsg::unsafe_arena_set_allocated_ballinfo(::IntelliSwing::SensorRunningMsg_BallFlightInfo* ballinfo) {
  clear_runState();
  if (ballinfo) {
    set_has_ballinfo();
    runState_.ballinfo_ = ballinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IntelliSwing.SensorRunningMsg.ballInfo)
}
inline ::IntelliSwing::SensorRunningMsg_BallFlightInfo* SensorRunningMsg::_internal_mutable_ballinfo() {
  if (!_internal_has_ballinfo()) {
    clear_runState();
    set_has_ballinfo();
    runState_.ballinfo_ = CreateMaybeMessage< ::IntelliSwing::SensorRunningMsg_BallFlightInfo >(GetArenaForAllocation());
  }
  return runState_.ballinfo_;
}
inline ::IntelliSwing::SensorRunningMsg_BallFlightInfo* SensorRunningMsg::mutable_ballinfo() {
  ::IntelliSwing::SensorRunningMsg_BallFlightInfo* _msg = _internal_mutable_ballinfo();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.SensorRunningMsg.ballInfo)
  return _msg;
}

// .IntelliSwing.SensorRunningMsg.ClubPathInfo clubInfo = 6;
inline bool SensorRunningMsg::_internal_has_clubinfo() const {
  return runState_case() == kClubInfo;
}
inline bool SensorRunningMsg::has_clubinfo() const {
  return _internal_has_clubinfo();
}
inline void SensorRunningMsg::set_has_clubinfo() {
  _oneof_case_[0] = kClubInfo;
}
inline void SensorRunningMsg::clear_clubinfo() {
  if (_internal_has_clubinfo()) {
    if (GetArenaForAllocation() == nullptr) {
      delete runState_.clubinfo_;
    }
    clear_has_runState();
  }
}
inline ::IntelliSwing::SensorRunningMsg_ClubPathInfo* SensorRunningMsg::release_clubinfo() {
  // @@protoc_insertion_point(field_release:IntelliSwing.SensorRunningMsg.clubInfo)
  if (_internal_has_clubinfo()) {
    clear_has_runState();
      ::IntelliSwing::SensorRunningMsg_ClubPathInfo* temp = runState_.clubinfo_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    runState_.clubinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::IntelliSwing::SensorRunningMsg_ClubPathInfo& SensorRunningMsg::_internal_clubinfo() const {
  return _internal_has_clubinfo()
      ? *runState_.clubinfo_
      : reinterpret_cast< ::IntelliSwing::SensorRunningMsg_ClubPathInfo&>(::IntelliSwing::_SensorRunningMsg_ClubPathInfo_default_instance_);
}
inline const ::IntelliSwing::SensorRunningMsg_ClubPathInfo& SensorRunningMsg::clubinfo() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.clubInfo)
  return _internal_clubinfo();
}
inline ::IntelliSwing::SensorRunningMsg_ClubPathInfo* SensorRunningMsg::unsafe_arena_release_clubinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:IntelliSwing.SensorRunningMsg.clubInfo)
  if (_internal_has_clubinfo()) {
    clear_has_runState();
    ::IntelliSwing::SensorRunningMsg_ClubPathInfo* temp = runState_.clubinfo_;
    runState_.clubinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorRunningMsg::unsafe_arena_set_allocated_clubinfo(::IntelliSwing::SensorRunningMsg_ClubPathInfo* clubinfo) {
  clear_runState();
  if (clubinfo) {
    set_has_clubinfo();
    runState_.clubinfo_ = clubinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IntelliSwing.SensorRunningMsg.clubInfo)
}
inline ::IntelliSwing::SensorRunningMsg_ClubPathInfo* SensorRunningMsg::_internal_mutable_clubinfo() {
  if (!_internal_has_clubinfo()) {
    clear_runState();
    set_has_clubinfo();
    runState_.clubinfo_ = CreateMaybeMessage< ::IntelliSwing::SensorRunningMsg_ClubPathInfo >(GetArenaForAllocation());
  }
  return runState_.clubinfo_;
}
inline ::IntelliSwing::SensorRunningMsg_ClubPathInfo* SensorRunningMsg::mutable_clubinfo() {
  ::IntelliSwing::SensorRunningMsg_ClubPathInfo* _msg = _internal_mutable_clubinfo();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.SensorRunningMsg.clubInfo)
  return _msg;
}

// .IntelliSwing.SensorRunningMsg.Heartbeat heartBeat = 7;
inline bool SensorRunningMsg::_internal_has_heartbeat() const {
  return runState_case() == kHeartBeat;
}
inline bool SensorRunningMsg::has_heartbeat() const {
  return _internal_has_heartbeat();
}
inline void SensorRunningMsg::set_has_heartbeat() {
  _oneof_case_[0] = kHeartBeat;
}
inline void SensorRunningMsg::clear_heartbeat() {
  if (_internal_has_heartbeat()) {
    if (GetArenaForAllocation() == nullptr) {
      delete runState_.heartbeat_;
    }
    clear_has_runState();
  }
}
inline ::IntelliSwing::SensorRunningMsg_Heartbeat* SensorRunningMsg::release_heartbeat() {
  // @@protoc_insertion_point(field_release:IntelliSwing.SensorRunningMsg.heartBeat)
  if (_internal_has_heartbeat()) {
    clear_has_runState();
      ::IntelliSwing::SensorRunningMsg_Heartbeat* temp = runState_.heartbeat_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    runState_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::IntelliSwing::SensorRunningMsg_Heartbeat& SensorRunningMsg::_internal_heartbeat() const {
  return _internal_has_heartbeat()
      ? *runState_.heartbeat_
      : reinterpret_cast< ::IntelliSwing::SensorRunningMsg_Heartbeat&>(::IntelliSwing::_SensorRunningMsg_Heartbeat_default_instance_);
}
inline const ::IntelliSwing::SensorRunningMsg_Heartbeat& SensorRunningMsg::heartbeat() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorRunningMsg.heartBeat)
  return _internal_heartbeat();
}
inline ::IntelliSwing::SensorRunningMsg_Heartbeat* SensorRunningMsg::unsafe_arena_release_heartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:IntelliSwing.SensorRunningMsg.heartBeat)
  if (_internal_has_heartbeat()) {
    clear_has_runState();
    ::IntelliSwing::SensorRunningMsg_Heartbeat* temp = runState_.heartbeat_;
    runState_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SensorRunningMsg::unsafe_arena_set_allocated_heartbeat(::IntelliSwing::SensorRunningMsg_Heartbeat* heartbeat) {
  clear_runState();
  if (heartbeat) {
    set_has_heartbeat();
    runState_.heartbeat_ = heartbeat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IntelliSwing.SensorRunningMsg.heartBeat)
}
inline ::IntelliSwing::SensorRunningMsg_Heartbeat* SensorRunningMsg::_internal_mutable_heartbeat() {
  if (!_internal_has_heartbeat()) {
    clear_runState();
    set_has_heartbeat();
    runState_.heartbeat_ = CreateMaybeMessage< ::IntelliSwing::SensorRunningMsg_Heartbeat >(GetArenaForAllocation());
  }
  return runState_.heartbeat_;
}
inline ::IntelliSwing::SensorRunningMsg_Heartbeat* SensorRunningMsg::mutable_heartbeat() {
  ::IntelliSwing::SensorRunningMsg_Heartbeat* _msg = _internal_mutable_heartbeat();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.SensorRunningMsg.heartBeat)
  return _msg;
}

inline bool SensorRunningMsg::has_runState() const {
  return runState_case() != RUNSTATE_NOT_SET;
}
inline void SensorRunningMsg::clear_has_runState() {
  _oneof_case_[0] = RUNSTATE_NOT_SET;
}
inline SensorRunningMsg::RunStateCase SensorRunningMsg::runState_case() const {
  return SensorRunningMsg::RunStateCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ShotImageRequest

// int32 shotId = 1;
inline void ShotImageRequest::clear_shotid() {
  shotid_ = 0;
}
inline int32_t ShotImageRequest::_internal_shotid() const {
  return shotid_;
}
inline int32_t ShotImageRequest::shotid() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.ShotImageRequest.shotId)
  return _internal_shotid();
}
inline void ShotImageRequest::_internal_set_shotid(int32_t value) {
  
  shotid_ = value;
}
inline void ShotImageRequest::set_shotid(int32_t value) {
  _internal_set_shotid(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.ShotImageRequest.shotId)
}

// -------------------------------------------------------------------

// ImageData_Image_Marker

// .IntelliSwing.Point2i position = 1;
inline bool ImageData_Image_Marker::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool ImageData_Image_Marker::has_position() const {
  return _internal_has_position();
}
inline const ::IntelliSwing::Point2i& ImageData_Image_Marker::_internal_position() const {
  const ::IntelliSwing::Point2i* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::IntelliSwing::Point2i&>(
      ::IntelliSwing::_Point2i_default_instance_);
}
inline const ::IntelliSwing::Point2i& ImageData_Image_Marker::position() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.ImageData.Image.Marker.position)
  return _internal_position();
}
inline void ImageData_Image_Marker::unsafe_arena_set_allocated_position(
    ::IntelliSwing::Point2i* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IntelliSwing.ImageData.Image.Marker.position)
}
inline ::IntelliSwing::Point2i* ImageData_Image_Marker::release_position() {
  
  ::IntelliSwing::Point2i* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::IntelliSwing::Point2i* ImageData_Image_Marker::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:IntelliSwing.ImageData.Image.Marker.position)
  
  ::IntelliSwing::Point2i* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::IntelliSwing::Point2i* ImageData_Image_Marker::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::IntelliSwing::Point2i>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::IntelliSwing::Point2i* ImageData_Image_Marker::mutable_position() {
  ::IntelliSwing::Point2i* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.ImageData.Image.Marker.position)
  return _msg;
}
inline void ImageData_Image_Marker::set_allocated_position(::IntelliSwing::Point2i* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:IntelliSwing.ImageData.Image.Marker.position)
}

// string tag = 2;
inline void ImageData_Image_Marker::clear_tag() {
  tag_.ClearToEmpty();
}
inline const std::string& ImageData_Image_Marker::tag() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.ImageData.Image.Marker.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageData_Image_Marker::set_tag(ArgT0&& arg0, ArgT... args) {
 
 tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IntelliSwing.ImageData.Image.Marker.tag)
}
inline std::string* ImageData_Image_Marker::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.ImageData.Image.Marker.tag)
  return _s;
}
inline const std::string& ImageData_Image_Marker::_internal_tag() const {
  return tag_.Get();
}
inline void ImageData_Image_Marker::_internal_set_tag(const std::string& value) {
  
  tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImageData_Image_Marker::_internal_mutable_tag() {
  
  return tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImageData_Image_Marker::release_tag() {
  // @@protoc_insertion_point(field_release:IntelliSwing.ImageData.Image.Marker.tag)
  return tag_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImageData_Image_Marker::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IntelliSwing.ImageData.Image.Marker.tag)
}

// -------------------------------------------------------------------

// ImageData_Image

// int32 imageType = 1;
inline void ImageData_Image::clear_imagetype() {
  imagetype_ = 0;
}
inline int32_t ImageData_Image::_internal_imagetype() const {
  return imagetype_;
}
inline int32_t ImageData_Image::imagetype() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.ImageData.Image.imageType)
  return _internal_imagetype();
}
inline void ImageData_Image::_internal_set_imagetype(int32_t value) {
  
  imagetype_ = value;
}
inline void ImageData_Image::set_imagetype(int32_t value) {
  _internal_set_imagetype(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.ImageData.Image.imageType)
}

// bytes data = 2;
inline void ImageData_Image::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& ImageData_Image::data() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.ImageData.Image.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageData_Image::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IntelliSwing.ImageData.Image.data)
}
inline std::string* ImageData_Image::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.ImageData.Image.data)
  return _s;
}
inline const std::string& ImageData_Image::_internal_data() const {
  return data_.Get();
}
inline void ImageData_Image::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImageData_Image::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImageData_Image::release_data() {
  // @@protoc_insertion_point(field_release:IntelliSwing.ImageData.Image.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImageData_Image::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IntelliSwing.ImageData.Image.data)
}

// int32 width = 3;
inline void ImageData_Image::clear_width() {
  width_ = 0;
}
inline int32_t ImageData_Image::_internal_width() const {
  return width_;
}
inline int32_t ImageData_Image::width() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.ImageData.Image.width)
  return _internal_width();
}
inline void ImageData_Image::_internal_set_width(int32_t value) {
  
  width_ = value;
}
inline void ImageData_Image::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.ImageData.Image.width)
}

// int32 height = 4;
inline void ImageData_Image::clear_height() {
  height_ = 0;
}
inline int32_t ImageData_Image::_internal_height() const {
  return height_;
}
inline int32_t ImageData_Image::height() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.ImageData.Image.height)
  return _internal_height();
}
inline void ImageData_Image::_internal_set_height(int32_t value) {
  
  height_ = value;
}
inline void ImageData_Image::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.ImageData.Image.height)
}

// int32 channel = 5;
inline void ImageData_Image::clear_channel() {
  channel_ = 0;
}
inline int32_t ImageData_Image::_internal_channel() const {
  return channel_;
}
inline int32_t ImageData_Image::channel() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.ImageData.Image.channel)
  return _internal_channel();
}
inline void ImageData_Image::_internal_set_channel(int32_t value) {
  
  channel_ = value;
}
inline void ImageData_Image::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.ImageData.Image.channel)
}

// int32 dataType = 6;
inline void ImageData_Image::clear_datatype() {
  datatype_ = 0;
}
inline int32_t ImageData_Image::_internal_datatype() const {
  return datatype_;
}
inline int32_t ImageData_Image::datatype() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.ImageData.Image.dataType)
  return _internal_datatype();
}
inline void ImageData_Image::_internal_set_datatype(int32_t value) {
  
  datatype_ = value;
}
inline void ImageData_Image::set_datatype(int32_t value) {
  _internal_set_datatype(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.ImageData.Image.dataType)
}

// string tag = 7;
inline void ImageData_Image::clear_tag() {
  tag_.ClearToEmpty();
}
inline const std::string& ImageData_Image::tag() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.ImageData.Image.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImageData_Image::set_tag(ArgT0&& arg0, ArgT... args) {
 
 tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IntelliSwing.ImageData.Image.tag)
}
inline std::string* ImageData_Image::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.ImageData.Image.tag)
  return _s;
}
inline const std::string& ImageData_Image::_internal_tag() const {
  return tag_.Get();
}
inline void ImageData_Image::_internal_set_tag(const std::string& value) {
  
  tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ImageData_Image::_internal_mutable_tag() {
  
  return tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ImageData_Image::release_tag() {
  // @@protoc_insertion_point(field_release:IntelliSwing.ImageData.Image.tag)
  return tag_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ImageData_Image::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IntelliSwing.ImageData.Image.tag)
}

// repeated .IntelliSwing.ImageData.Image.Marker markers = 8;
inline int ImageData_Image::_internal_markers_size() const {
  return markers_.size();
}
inline int ImageData_Image::markers_size() const {
  return _internal_markers_size();
}
inline void ImageData_Image::clear_markers() {
  markers_.Clear();
}
inline ::IntelliSwing::ImageData_Image_Marker* ImageData_Image::mutable_markers(int index) {
  // @@protoc_insertion_point(field_mutable:IntelliSwing.ImageData.Image.markers)
  return markers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntelliSwing::ImageData_Image_Marker >*
ImageData_Image::mutable_markers() {
  // @@protoc_insertion_point(field_mutable_list:IntelliSwing.ImageData.Image.markers)
  return &markers_;
}
inline const ::IntelliSwing::ImageData_Image_Marker& ImageData_Image::_internal_markers(int index) const {
  return markers_.Get(index);
}
inline const ::IntelliSwing::ImageData_Image_Marker& ImageData_Image::markers(int index) const {
  // @@protoc_insertion_point(field_get:IntelliSwing.ImageData.Image.markers)
  return _internal_markers(index);
}
inline ::IntelliSwing::ImageData_Image_Marker* ImageData_Image::_internal_add_markers() {
  return markers_.Add();
}
inline ::IntelliSwing::ImageData_Image_Marker* ImageData_Image::add_markers() {
  ::IntelliSwing::ImageData_Image_Marker* _add = _internal_add_markers();
  // @@protoc_insertion_point(field_add:IntelliSwing.ImageData.Image.markers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntelliSwing::ImageData_Image_Marker >&
ImageData_Image::markers() const {
  // @@protoc_insertion_point(field_list:IntelliSwing.ImageData.Image.markers)
  return markers_;
}

// -------------------------------------------------------------------

// ImageData

// .IntelliSwing.ReturnMsg state = 1;
inline bool ImageData::_internal_has_state() const {
  return this != internal_default_instance() && state_ != nullptr;
}
inline bool ImageData::has_state() const {
  return _internal_has_state();
}
inline const ::IntelliSwing::ReturnMsg& ImageData::_internal_state() const {
  const ::IntelliSwing::ReturnMsg* p = state_;
  return p != nullptr ? *p : reinterpret_cast<const ::IntelliSwing::ReturnMsg&>(
      ::IntelliSwing::_ReturnMsg_default_instance_);
}
inline const ::IntelliSwing::ReturnMsg& ImageData::state() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.ImageData.state)
  return _internal_state();
}
inline void ImageData::unsafe_arena_set_allocated_state(
    ::IntelliSwing::ReturnMsg* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_);
  }
  state_ = state;
  if (state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IntelliSwing.ImageData.state)
}
inline ::IntelliSwing::ReturnMsg* ImageData::release_state() {
  
  ::IntelliSwing::ReturnMsg* temp = state_;
  state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::IntelliSwing::ReturnMsg* ImageData::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:IntelliSwing.ImageData.state)
  
  ::IntelliSwing::ReturnMsg* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::IntelliSwing::ReturnMsg* ImageData::_internal_mutable_state() {
  
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::IntelliSwing::ReturnMsg>(GetArenaForAllocation());
    state_ = p;
  }
  return state_;
}
inline ::IntelliSwing::ReturnMsg* ImageData::mutable_state() {
  ::IntelliSwing::ReturnMsg* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.ImageData.state)
  return _msg;
}
inline void ImageData::set_allocated_state(::IntelliSwing::ReturnMsg* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_);
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state));
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:IntelliSwing.ImageData.state)
}

// repeated .IntelliSwing.ImageData.Image images = 2;
inline int ImageData::_internal_images_size() const {
  return images_.size();
}
inline int ImageData::images_size() const {
  return _internal_images_size();
}
inline void ImageData::clear_images() {
  images_.Clear();
}
inline ::IntelliSwing::ImageData_Image* ImageData::mutable_images(int index) {
  // @@protoc_insertion_point(field_mutable:IntelliSwing.ImageData.images)
  return images_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntelliSwing::ImageData_Image >*
ImageData::mutable_images() {
  // @@protoc_insertion_point(field_mutable_list:IntelliSwing.ImageData.images)
  return &images_;
}
inline const ::IntelliSwing::ImageData_Image& ImageData::_internal_images(int index) const {
  return images_.Get(index);
}
inline const ::IntelliSwing::ImageData_Image& ImageData::images(int index) const {
  // @@protoc_insertion_point(field_get:IntelliSwing.ImageData.images)
  return _internal_images(index);
}
inline ::IntelliSwing::ImageData_Image* ImageData::_internal_add_images() {
  return images_.Add();
}
inline ::IntelliSwing::ImageData_Image* ImageData::add_images() {
  ::IntelliSwing::ImageData_Image* _add = _internal_add_images();
  // @@protoc_insertion_point(field_add:IntelliSwing.ImageData.images)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntelliSwing::ImageData_Image >&
ImageData::images() const {
  // @@protoc_insertion_point(field_list:IntelliSwing.ImageData.images)
  return images_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace IntelliSwing

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::IntelliSwing::InitializeMsg_Client> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IntelliSwing::InitializeMsg_Client>() {
  return ::IntelliSwing::InitializeMsg_Client_descriptor();
}
template <> struct is_proto_enum< ::IntelliSwing::StartMsg_ClubInformation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IntelliSwing::StartMsg_ClubInformation>() {
  return ::IntelliSwing::StartMsg_ClubInformation_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_IntelliSwingInterface_2eproto
