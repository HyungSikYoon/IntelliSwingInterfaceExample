// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IntelliSwingService.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_IntelliSwingService_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_IntelliSwingService_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "type.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_IntelliSwingService_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_IntelliSwingService_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_IntelliSwingService_2eproto;
namespace IntelliSwing {
class DeviceInfo;
struct DeviceInfoDefaultTypeInternal;
extern DeviceInfoDefaultTypeInternal _DeviceInfo_default_instance_;
class DiviceStatus;
struct DiviceStatusDefaultTypeInternal;
extern DiviceStatusDefaultTypeInternal _DiviceStatus_default_instance_;
class Firmware;
struct FirmwareDefaultTypeInternal;
extern FirmwareDefaultTypeInternal _Firmware_default_instance_;
class LogMessage;
struct LogMessageDefaultTypeInternal;
extern LogMessageDefaultTypeInternal _LogMessage_default_instance_;
class LogRequest;
struct LogRequestDefaultTypeInternal;
extern LogRequestDefaultTypeInternal _LogRequest_default_instance_;
class SensorStatistics;
struct SensorStatisticsDefaultTypeInternal;
extern SensorStatisticsDefaultTypeInternal _SensorStatistics_default_instance_;
class SiteCalibrationResult;
struct SiteCalibrationResultDefaultTypeInternal;
extern SiteCalibrationResultDefaultTypeInternal _SiteCalibrationResult_default_instance_;
class UpdateFirmwareResult;
struct UpdateFirmwareResultDefaultTypeInternal;
extern UpdateFirmwareResultDefaultTypeInternal _UpdateFirmwareResult_default_instance_;
}  // namespace IntelliSwing
PROTOBUF_NAMESPACE_OPEN
template<> ::IntelliSwing::DeviceInfo* Arena::CreateMaybeMessage<::IntelliSwing::DeviceInfo>(Arena*);
template<> ::IntelliSwing::DiviceStatus* Arena::CreateMaybeMessage<::IntelliSwing::DiviceStatus>(Arena*);
template<> ::IntelliSwing::Firmware* Arena::CreateMaybeMessage<::IntelliSwing::Firmware>(Arena*);
template<> ::IntelliSwing::LogMessage* Arena::CreateMaybeMessage<::IntelliSwing::LogMessage>(Arena*);
template<> ::IntelliSwing::LogRequest* Arena::CreateMaybeMessage<::IntelliSwing::LogRequest>(Arena*);
template<> ::IntelliSwing::SensorStatistics* Arena::CreateMaybeMessage<::IntelliSwing::SensorStatistics>(Arena*);
template<> ::IntelliSwing::SiteCalibrationResult* Arena::CreateMaybeMessage<::IntelliSwing::SiteCalibrationResult>(Arena*);
template<> ::IntelliSwing::UpdateFirmwareResult* Arena::CreateMaybeMessage<::IntelliSwing::UpdateFirmwareResult>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace IntelliSwing {

// ===================================================================

class DeviceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.DeviceInfo) */ {
 public:
  inline DeviceInfo() : DeviceInfo(nullptr) {}
  ~DeviceInfo() override;
  explicit constexpr DeviceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceInfo(const DeviceInfo& from);
  DeviceInfo(DeviceInfo&& from) noexcept
    : DeviceInfo() {
    *this = ::std::move(from);
  }

  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceInfo& operator=(DeviceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceInfo*>(
               &_DeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DeviceInfo& a, DeviceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeviceInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.DeviceInfo";
  }
  protected:
  explicit DeviceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceVerFieldNumber = 1,
    kFpgaVerFieldNumber = 2,
    kSoftwareVerFieldNumber = 3,
    kSerialNumberFieldNumber = 4,
    kSensorNameFieldNumber = 5,
  };
  // string deviceVer = 1;
  void clear_devicever();
  const std::string& devicever() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devicever(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devicever();
  PROTOBUF_NODISCARD std::string* release_devicever();
  void set_allocated_devicever(std::string* devicever);
  private:
  const std::string& _internal_devicever() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devicever(const std::string& value);
  std::string* _internal_mutable_devicever();
  public:

  // string fpgaVer = 2;
  void clear_fpgaver();
  const std::string& fpgaver() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fpgaver(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fpgaver();
  PROTOBUF_NODISCARD std::string* release_fpgaver();
  void set_allocated_fpgaver(std::string* fpgaver);
  private:
  const std::string& _internal_fpgaver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fpgaver(const std::string& value);
  std::string* _internal_mutable_fpgaver();
  public:

  // string softwareVer = 3;
  void clear_softwarever();
  const std::string& softwarever() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_softwarever(ArgT0&& arg0, ArgT... args);
  std::string* mutable_softwarever();
  PROTOBUF_NODISCARD std::string* release_softwarever();
  void set_allocated_softwarever(std::string* softwarever);
  private:
  const std::string& _internal_softwarever() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_softwarever(const std::string& value);
  std::string* _internal_mutable_softwarever();
  public:

  // string serialNumber = 4;
  void clear_serialnumber();
  const std::string& serialnumber() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serialnumber(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serialnumber();
  PROTOBUF_NODISCARD std::string* release_serialnumber();
  void set_allocated_serialnumber(std::string* serialnumber);
  private:
  const std::string& _internal_serialnumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serialnumber(const std::string& value);
  std::string* _internal_mutable_serialnumber();
  public:

  // string sensorName = 5;
  void clear_sensorname();
  const std::string& sensorname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sensorname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sensorname();
  PROTOBUF_NODISCARD std::string* release_sensorname();
  void set_allocated_sensorname(std::string* sensorname);
  private:
  const std::string& _internal_sensorname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sensorname(const std::string& value);
  std::string* _internal_mutable_sensorname();
  public:

  // @@protoc_insertion_point(class_scope:IntelliSwing.DeviceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devicever_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fpgaver_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr softwarever_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialnumber_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sensorname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingService_2eproto;
};
// -------------------------------------------------------------------

class DiviceStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.DiviceStatus) */ {
 public:
  inline DiviceStatus() : DiviceStatus(nullptr) {}
  ~DiviceStatus() override;
  explicit constexpr DiviceStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiviceStatus(const DiviceStatus& from);
  DiviceStatus(DiviceStatus&& from) noexcept
    : DiviceStatus() {
    *this = ::std::move(from);
  }

  inline DiviceStatus& operator=(const DiviceStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiviceStatus& operator=(DiviceStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiviceStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiviceStatus* internal_default_instance() {
    return reinterpret_cast<const DiviceStatus*>(
               &_DiviceStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DiviceStatus& a, DiviceStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(DiviceStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiviceStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DiviceStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DiviceStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DiviceStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DiviceStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiviceStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.DiviceStatus";
  }
  protected:
  explicit DiviceStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorStateFieldNumber = 1,
    kSystemStateFieldNumber = 2,
    kDeviceTemperatureFieldNumber = 5,
    kBatteryInfoFieldNumber = 6,
  };
  // repeated .IntelliSwing.ReturnMsg sensorState = 1;
  int sensorstate_size() const;
  private:
  int _internal_sensorstate_size() const;
  public:
  void clear_sensorstate();
  ::IntelliSwing::ReturnMsg* mutable_sensorstate(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntelliSwing::ReturnMsg >*
      mutable_sensorstate();
  private:
  const ::IntelliSwing::ReturnMsg& _internal_sensorstate(int index) const;
  ::IntelliSwing::ReturnMsg* _internal_add_sensorstate();
  public:
  const ::IntelliSwing::ReturnMsg& sensorstate(int index) const;
  ::IntelliSwing::ReturnMsg* add_sensorstate();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntelliSwing::ReturnMsg >&
      sensorstate() const;

  // .IntelliSwing.ReturnMsg systemState = 2;
  bool has_systemstate() const;
  private:
  bool _internal_has_systemstate() const;
  public:
  void clear_systemstate();
  const ::IntelliSwing::ReturnMsg& systemstate() const;
  PROTOBUF_NODISCARD ::IntelliSwing::ReturnMsg* release_systemstate();
  ::IntelliSwing::ReturnMsg* mutable_systemstate();
  void set_allocated_systemstate(::IntelliSwing::ReturnMsg* systemstate);
  private:
  const ::IntelliSwing::ReturnMsg& _internal_systemstate() const;
  ::IntelliSwing::ReturnMsg* _internal_mutable_systemstate();
  public:
  void unsafe_arena_set_allocated_systemstate(
      ::IntelliSwing::ReturnMsg* systemstate);
  ::IntelliSwing::ReturnMsg* unsafe_arena_release_systemstate();

  // float deviceTemperature = 5;
  void clear_devicetemperature();
  float devicetemperature() const;
  void set_devicetemperature(float value);
  private:
  float _internal_devicetemperature() const;
  void _internal_set_devicetemperature(float value);
  public:

  // float batteryInfo = 6;
  void clear_batteryinfo();
  float batteryinfo() const;
  void set_batteryinfo(float value);
  private:
  float _internal_batteryinfo() const;
  void _internal_set_batteryinfo(float value);
  public:

  // @@protoc_insertion_point(class_scope:IntelliSwing.DiviceStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntelliSwing::ReturnMsg > sensorstate_;
  ::IntelliSwing::ReturnMsg* systemstate_;
  float devicetemperature_;
  float batteryinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingService_2eproto;
};
// -------------------------------------------------------------------

class LogRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.LogRequest) */ {
 public:
  inline LogRequest() : LogRequest(nullptr) {}
  ~LogRequest() override;
  explicit constexpr LogRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogRequest(const LogRequest& from);
  LogRequest(LogRequest&& from) noexcept
    : LogRequest() {
    *this = ::std::move(from);
  }

  inline LogRequest& operator=(const LogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogRequest& operator=(LogRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogRequest* internal_default_instance() {
    return reinterpret_cast<const LogRequest*>(
               &_LogRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LogRequest& a, LogRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LogRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.LogRequest";
  }
  protected:
  explicit LogRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSystemRangeFieldNumber = 1,
    kProcessingLograngeFieldNumber = 2,
  };
  // int32 systemRange = 1;
  void clear_systemrange();
  int32_t systemrange() const;
  void set_systemrange(int32_t value);
  private:
  int32_t _internal_systemrange() const;
  void _internal_set_systemrange(int32_t value);
  public:

  // int32 processingLogrange = 2;
  void clear_processinglogrange();
  int32_t processinglogrange() const;
  void set_processinglogrange(int32_t value);
  private:
  int32_t _internal_processinglogrange() const;
  void _internal_set_processinglogrange(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:IntelliSwing.LogRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t systemrange_;
  int32_t processinglogrange_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingService_2eproto;
};
// -------------------------------------------------------------------

class LogMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.LogMessage) */ {
 public:
  inline LogMessage() : LogMessage(nullptr) {}
  ~LogMessage() override;
  explicit constexpr LogMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogMessage(const LogMessage& from);
  LogMessage(LogMessage&& from) noexcept
    : LogMessage() {
    *this = ::std::move(from);
  }

  inline LogMessage& operator=(const LogMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogMessage& operator=(LogMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogMessage* internal_default_instance() {
    return reinterpret_cast<const LogMessage*>(
               &_LogMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LogMessage& a, LogMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(LogMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.LogMessage";
  }
  protected:
  explicit LogMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSystemLogFieldNumber = 1,
    kProcessingLogFieldNumber = 2,
  };
  // repeated string systemLog = 1;
  int systemlog_size() const;
  private:
  int _internal_systemlog_size() const;
  public:
  void clear_systemlog();
  const std::string& systemlog(int index) const;
  std::string* mutable_systemlog(int index);
  void set_systemlog(int index, const std::string& value);
  void set_systemlog(int index, std::string&& value);
  void set_systemlog(int index, const char* value);
  void set_systemlog(int index, const char* value, size_t size);
  std::string* add_systemlog();
  void add_systemlog(const std::string& value);
  void add_systemlog(std::string&& value);
  void add_systemlog(const char* value);
  void add_systemlog(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& systemlog() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_systemlog();
  private:
  const std::string& _internal_systemlog(int index) const;
  std::string* _internal_add_systemlog();
  public:

  // repeated string processingLog = 2;
  int processinglog_size() const;
  private:
  int _internal_processinglog_size() const;
  public:
  void clear_processinglog();
  const std::string& processinglog(int index) const;
  std::string* mutable_processinglog(int index);
  void set_processinglog(int index, const std::string& value);
  void set_processinglog(int index, std::string&& value);
  void set_processinglog(int index, const char* value);
  void set_processinglog(int index, const char* value, size_t size);
  std::string* add_processinglog();
  void add_processinglog(const std::string& value);
  void add_processinglog(std::string&& value);
  void add_processinglog(const char* value);
  void add_processinglog(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& processinglog() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_processinglog();
  private:
  const std::string& _internal_processinglog(int index) const;
  std::string* _internal_add_processinglog();
  public:

  // @@protoc_insertion_point(class_scope:IntelliSwing.LogMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> systemlog_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> processinglog_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingService_2eproto;
};
// -------------------------------------------------------------------

class SensorStatistics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.SensorStatistics) */ {
 public:
  inline SensorStatistics() : SensorStatistics(nullptr) {}
  ~SensorStatistics() override;
  explicit constexpr SensorStatistics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorStatistics(const SensorStatistics& from);
  SensorStatistics(SensorStatistics&& from) noexcept
    : SensorStatistics() {
    *this = ::std::move(from);
  }

  inline SensorStatistics& operator=(const SensorStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorStatistics& operator=(SensorStatistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorStatistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorStatistics* internal_default_instance() {
    return reinterpret_cast<const SensorStatistics*>(
               &_SensorStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SensorStatistics& a, SensorStatistics& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorStatistics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorStatistics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorStatistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorStatistics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorStatistics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SensorStatistics& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorStatistics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.SensorStatistics";
  }
  protected:
  explicit SensorStatistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShotCountFieldNumber = 1,
  };
  // int32 shot_count = 1;
  void clear_shot_count();
  int32_t shot_count() const;
  void set_shot_count(int32_t value);
  private:
  int32_t _internal_shot_count() const;
  void _internal_set_shot_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:IntelliSwing.SensorStatistics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t shot_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingService_2eproto;
};
// -------------------------------------------------------------------

class SiteCalibrationResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.SiteCalibrationResult) */ {
 public:
  inline SiteCalibrationResult() : SiteCalibrationResult(nullptr) {}
  ~SiteCalibrationResult() override;
  explicit constexpr SiteCalibrationResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SiteCalibrationResult(const SiteCalibrationResult& from);
  SiteCalibrationResult(SiteCalibrationResult&& from) noexcept
    : SiteCalibrationResult() {
    *this = ::std::move(from);
  }

  inline SiteCalibrationResult& operator=(const SiteCalibrationResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline SiteCalibrationResult& operator=(SiteCalibrationResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SiteCalibrationResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const SiteCalibrationResult* internal_default_instance() {
    return reinterpret_cast<const SiteCalibrationResult*>(
               &_SiteCalibrationResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SiteCalibrationResult& a, SiteCalibrationResult& b) {
    a.Swap(&b);
  }
  inline void Swap(SiteCalibrationResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SiteCalibrationResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SiteCalibrationResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SiteCalibrationResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SiteCalibrationResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SiteCalibrationResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SiteCalibrationResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.SiteCalibrationResult";
  }
  protected:
  explicit SiteCalibrationResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // .IntelliSwing.ReturnMsg state = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::IntelliSwing::ReturnMsg& state() const;
  PROTOBUF_NODISCARD ::IntelliSwing::ReturnMsg* release_state();
  ::IntelliSwing::ReturnMsg* mutable_state();
  void set_allocated_state(::IntelliSwing::ReturnMsg* state);
  private:
  const ::IntelliSwing::ReturnMsg& _internal_state() const;
  ::IntelliSwing::ReturnMsg* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::IntelliSwing::ReturnMsg* state);
  ::IntelliSwing::ReturnMsg* unsafe_arena_release_state();

  // @@protoc_insertion_point(class_scope:IntelliSwing.SiteCalibrationResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::IntelliSwing::ReturnMsg* state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingService_2eproto;
};
// -------------------------------------------------------------------

class Firmware final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.Firmware) */ {
 public:
  inline Firmware() : Firmware(nullptr) {}
  ~Firmware() override;
  explicit constexpr Firmware(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Firmware(const Firmware& from);
  Firmware(Firmware&& from) noexcept
    : Firmware() {
    *this = ::std::move(from);
  }

  inline Firmware& operator=(const Firmware& from) {
    CopyFrom(from);
    return *this;
  }
  inline Firmware& operator=(Firmware&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Firmware& default_instance() {
    return *internal_default_instance();
  }
  static inline const Firmware* internal_default_instance() {
    return reinterpret_cast<const Firmware*>(
               &_Firmware_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Firmware& a, Firmware& b) {
    a.Swap(&b);
  }
  inline void Swap(Firmware* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Firmware* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Firmware* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Firmware>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Firmware& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Firmware& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Firmware* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.Firmware";
  }
  protected:
  explicit Firmware(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSensorFirmwareFieldNumber = 1,
    kFpgaFirmwareFieldNumber = 2,
  };
  // bytes sensorFirmware = 1;
  void clear_sensorfirmware();
  const std::string& sensorfirmware() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sensorfirmware(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sensorfirmware();
  PROTOBUF_NODISCARD std::string* release_sensorfirmware();
  void set_allocated_sensorfirmware(std::string* sensorfirmware);
  private:
  const std::string& _internal_sensorfirmware() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sensorfirmware(const std::string& value);
  std::string* _internal_mutable_sensorfirmware();
  public:

  // bytes fpgaFirmware = 2;
  void clear_fpgafirmware();
  const std::string& fpgafirmware() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fpgafirmware(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fpgafirmware();
  PROTOBUF_NODISCARD std::string* release_fpgafirmware();
  void set_allocated_fpgafirmware(std::string* fpgafirmware);
  private:
  const std::string& _internal_fpgafirmware() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fpgafirmware(const std::string& value);
  std::string* _internal_mutable_fpgafirmware();
  public:

  // @@protoc_insertion_point(class_scope:IntelliSwing.Firmware)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sensorfirmware_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fpgafirmware_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingService_2eproto;
};
// -------------------------------------------------------------------

class UpdateFirmwareResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IntelliSwing.UpdateFirmwareResult) */ {
 public:
  inline UpdateFirmwareResult() : UpdateFirmwareResult(nullptr) {}
  ~UpdateFirmwareResult() override;
  explicit constexpr UpdateFirmwareResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateFirmwareResult(const UpdateFirmwareResult& from);
  UpdateFirmwareResult(UpdateFirmwareResult&& from) noexcept
    : UpdateFirmwareResult() {
    *this = ::std::move(from);
  }

  inline UpdateFirmwareResult& operator=(const UpdateFirmwareResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateFirmwareResult& operator=(UpdateFirmwareResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateFirmwareResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateFirmwareResult* internal_default_instance() {
    return reinterpret_cast<const UpdateFirmwareResult*>(
               &_UpdateFirmwareResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(UpdateFirmwareResult& a, UpdateFirmwareResult& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateFirmwareResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateFirmwareResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateFirmwareResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateFirmwareResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateFirmwareResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateFirmwareResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateFirmwareResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IntelliSwing.UpdateFirmwareResult";
  }
  protected:
  explicit UpdateFirmwareResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFpgaStateFieldNumber = 1,
    kSensorSWFieldNumber = 2,
  };
  // .IntelliSwing.ReturnMsg FpgaState = 1;
  bool has_fpgastate() const;
  private:
  bool _internal_has_fpgastate() const;
  public:
  void clear_fpgastate();
  const ::IntelliSwing::ReturnMsg& fpgastate() const;
  PROTOBUF_NODISCARD ::IntelliSwing::ReturnMsg* release_fpgastate();
  ::IntelliSwing::ReturnMsg* mutable_fpgastate();
  void set_allocated_fpgastate(::IntelliSwing::ReturnMsg* fpgastate);
  private:
  const ::IntelliSwing::ReturnMsg& _internal_fpgastate() const;
  ::IntelliSwing::ReturnMsg* _internal_mutable_fpgastate();
  public:
  void unsafe_arena_set_allocated_fpgastate(
      ::IntelliSwing::ReturnMsg* fpgastate);
  ::IntelliSwing::ReturnMsg* unsafe_arena_release_fpgastate();

  // .IntelliSwing.ReturnMsg SensorSW = 2;
  bool has_sensorsw() const;
  private:
  bool _internal_has_sensorsw() const;
  public:
  void clear_sensorsw();
  const ::IntelliSwing::ReturnMsg& sensorsw() const;
  PROTOBUF_NODISCARD ::IntelliSwing::ReturnMsg* release_sensorsw();
  ::IntelliSwing::ReturnMsg* mutable_sensorsw();
  void set_allocated_sensorsw(::IntelliSwing::ReturnMsg* sensorsw);
  private:
  const ::IntelliSwing::ReturnMsg& _internal_sensorsw() const;
  ::IntelliSwing::ReturnMsg* _internal_mutable_sensorsw();
  public:
  void unsafe_arena_set_allocated_sensorsw(
      ::IntelliSwing::ReturnMsg* sensorsw);
  ::IntelliSwing::ReturnMsg* unsafe_arena_release_sensorsw();

  // @@protoc_insertion_point(class_scope:IntelliSwing.UpdateFirmwareResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::IntelliSwing::ReturnMsg* fpgastate_;
  ::IntelliSwing::ReturnMsg* sensorsw_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_IntelliSwingService_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DeviceInfo

// string deviceVer = 1;
inline void DeviceInfo::clear_devicever() {
  devicever_.ClearToEmpty();
}
inline const std::string& DeviceInfo::devicever() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.DeviceInfo.deviceVer)
  return _internal_devicever();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_devicever(ArgT0&& arg0, ArgT... args) {
 
 devicever_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IntelliSwing.DeviceInfo.deviceVer)
}
inline std::string* DeviceInfo::mutable_devicever() {
  std::string* _s = _internal_mutable_devicever();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.DeviceInfo.deviceVer)
  return _s;
}
inline const std::string& DeviceInfo::_internal_devicever() const {
  return devicever_.Get();
}
inline void DeviceInfo::_internal_set_devicever(const std::string& value) {
  
  devicever_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_devicever() {
  
  return devicever_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_devicever() {
  // @@protoc_insertion_point(field_release:IntelliSwing.DeviceInfo.deviceVer)
  return devicever_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceInfo::set_allocated_devicever(std::string* devicever) {
  if (devicever != nullptr) {
    
  } else {
    
  }
  devicever_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), devicever,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (devicever_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    devicever_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IntelliSwing.DeviceInfo.deviceVer)
}

// string fpgaVer = 2;
inline void DeviceInfo::clear_fpgaver() {
  fpgaver_.ClearToEmpty();
}
inline const std::string& DeviceInfo::fpgaver() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.DeviceInfo.fpgaVer)
  return _internal_fpgaver();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_fpgaver(ArgT0&& arg0, ArgT... args) {
 
 fpgaver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IntelliSwing.DeviceInfo.fpgaVer)
}
inline std::string* DeviceInfo::mutable_fpgaver() {
  std::string* _s = _internal_mutable_fpgaver();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.DeviceInfo.fpgaVer)
  return _s;
}
inline const std::string& DeviceInfo::_internal_fpgaver() const {
  return fpgaver_.Get();
}
inline void DeviceInfo::_internal_set_fpgaver(const std::string& value) {
  
  fpgaver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_fpgaver() {
  
  return fpgaver_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_fpgaver() {
  // @@protoc_insertion_point(field_release:IntelliSwing.DeviceInfo.fpgaVer)
  return fpgaver_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceInfo::set_allocated_fpgaver(std::string* fpgaver) {
  if (fpgaver != nullptr) {
    
  } else {
    
  }
  fpgaver_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fpgaver,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fpgaver_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fpgaver_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IntelliSwing.DeviceInfo.fpgaVer)
}

// string softwareVer = 3;
inline void DeviceInfo::clear_softwarever() {
  softwarever_.ClearToEmpty();
}
inline const std::string& DeviceInfo::softwarever() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.DeviceInfo.softwareVer)
  return _internal_softwarever();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_softwarever(ArgT0&& arg0, ArgT... args) {
 
 softwarever_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IntelliSwing.DeviceInfo.softwareVer)
}
inline std::string* DeviceInfo::mutable_softwarever() {
  std::string* _s = _internal_mutable_softwarever();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.DeviceInfo.softwareVer)
  return _s;
}
inline const std::string& DeviceInfo::_internal_softwarever() const {
  return softwarever_.Get();
}
inline void DeviceInfo::_internal_set_softwarever(const std::string& value) {
  
  softwarever_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_softwarever() {
  
  return softwarever_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_softwarever() {
  // @@protoc_insertion_point(field_release:IntelliSwing.DeviceInfo.softwareVer)
  return softwarever_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceInfo::set_allocated_softwarever(std::string* softwarever) {
  if (softwarever != nullptr) {
    
  } else {
    
  }
  softwarever_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), softwarever,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (softwarever_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    softwarever_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IntelliSwing.DeviceInfo.softwareVer)
}

// string serialNumber = 4;
inline void DeviceInfo::clear_serialnumber() {
  serialnumber_.ClearToEmpty();
}
inline const std::string& DeviceInfo::serialnumber() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.DeviceInfo.serialNumber)
  return _internal_serialnumber();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_serialnumber(ArgT0&& arg0, ArgT... args) {
 
 serialnumber_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IntelliSwing.DeviceInfo.serialNumber)
}
inline std::string* DeviceInfo::mutable_serialnumber() {
  std::string* _s = _internal_mutable_serialnumber();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.DeviceInfo.serialNumber)
  return _s;
}
inline const std::string& DeviceInfo::_internal_serialnumber() const {
  return serialnumber_.Get();
}
inline void DeviceInfo::_internal_set_serialnumber(const std::string& value) {
  
  serialnumber_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_serialnumber() {
  
  return serialnumber_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_serialnumber() {
  // @@protoc_insertion_point(field_release:IntelliSwing.DeviceInfo.serialNumber)
  return serialnumber_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceInfo::set_allocated_serialnumber(std::string* serialnumber) {
  if (serialnumber != nullptr) {
    
  } else {
    
  }
  serialnumber_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serialnumber,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serialnumber_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serialnumber_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IntelliSwing.DeviceInfo.serialNumber)
}

// string sensorName = 5;
inline void DeviceInfo::clear_sensorname() {
  sensorname_.ClearToEmpty();
}
inline const std::string& DeviceInfo::sensorname() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.DeviceInfo.sensorName)
  return _internal_sensorname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_sensorname(ArgT0&& arg0, ArgT... args) {
 
 sensorname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IntelliSwing.DeviceInfo.sensorName)
}
inline std::string* DeviceInfo::mutable_sensorname() {
  std::string* _s = _internal_mutable_sensorname();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.DeviceInfo.sensorName)
  return _s;
}
inline const std::string& DeviceInfo::_internal_sensorname() const {
  return sensorname_.Get();
}
inline void DeviceInfo::_internal_set_sensorname(const std::string& value) {
  
  sensorname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_sensorname() {
  
  return sensorname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_sensorname() {
  // @@protoc_insertion_point(field_release:IntelliSwing.DeviceInfo.sensorName)
  return sensorname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeviceInfo::set_allocated_sensorname(std::string* sensorname) {
  if (sensorname != nullptr) {
    
  } else {
    
  }
  sensorname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sensorname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sensorname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sensorname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IntelliSwing.DeviceInfo.sensorName)
}

// -------------------------------------------------------------------

// DiviceStatus

// repeated .IntelliSwing.ReturnMsg sensorState = 1;
inline int DiviceStatus::_internal_sensorstate_size() const {
  return sensorstate_.size();
}
inline int DiviceStatus::sensorstate_size() const {
  return _internal_sensorstate_size();
}
inline ::IntelliSwing::ReturnMsg* DiviceStatus::mutable_sensorstate(int index) {
  // @@protoc_insertion_point(field_mutable:IntelliSwing.DiviceStatus.sensorState)
  return sensorstate_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntelliSwing::ReturnMsg >*
DiviceStatus::mutable_sensorstate() {
  // @@protoc_insertion_point(field_mutable_list:IntelliSwing.DiviceStatus.sensorState)
  return &sensorstate_;
}
inline const ::IntelliSwing::ReturnMsg& DiviceStatus::_internal_sensorstate(int index) const {
  return sensorstate_.Get(index);
}
inline const ::IntelliSwing::ReturnMsg& DiviceStatus::sensorstate(int index) const {
  // @@protoc_insertion_point(field_get:IntelliSwing.DiviceStatus.sensorState)
  return _internal_sensorstate(index);
}
inline ::IntelliSwing::ReturnMsg* DiviceStatus::_internal_add_sensorstate() {
  return sensorstate_.Add();
}
inline ::IntelliSwing::ReturnMsg* DiviceStatus::add_sensorstate() {
  ::IntelliSwing::ReturnMsg* _add = _internal_add_sensorstate();
  // @@protoc_insertion_point(field_add:IntelliSwing.DiviceStatus.sensorState)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IntelliSwing::ReturnMsg >&
DiviceStatus::sensorstate() const {
  // @@protoc_insertion_point(field_list:IntelliSwing.DiviceStatus.sensorState)
  return sensorstate_;
}

// .IntelliSwing.ReturnMsg systemState = 2;
inline bool DiviceStatus::_internal_has_systemstate() const {
  return this != internal_default_instance() && systemstate_ != nullptr;
}
inline bool DiviceStatus::has_systemstate() const {
  return _internal_has_systemstate();
}
inline const ::IntelliSwing::ReturnMsg& DiviceStatus::_internal_systemstate() const {
  const ::IntelliSwing::ReturnMsg* p = systemstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::IntelliSwing::ReturnMsg&>(
      ::IntelliSwing::_ReturnMsg_default_instance_);
}
inline const ::IntelliSwing::ReturnMsg& DiviceStatus::systemstate() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.DiviceStatus.systemState)
  return _internal_systemstate();
}
inline void DiviceStatus::unsafe_arena_set_allocated_systemstate(
    ::IntelliSwing::ReturnMsg* systemstate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(systemstate_);
  }
  systemstate_ = systemstate;
  if (systemstate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IntelliSwing.DiviceStatus.systemState)
}
inline ::IntelliSwing::ReturnMsg* DiviceStatus::release_systemstate() {
  
  ::IntelliSwing::ReturnMsg* temp = systemstate_;
  systemstate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::IntelliSwing::ReturnMsg* DiviceStatus::unsafe_arena_release_systemstate() {
  // @@protoc_insertion_point(field_release:IntelliSwing.DiviceStatus.systemState)
  
  ::IntelliSwing::ReturnMsg* temp = systemstate_;
  systemstate_ = nullptr;
  return temp;
}
inline ::IntelliSwing::ReturnMsg* DiviceStatus::_internal_mutable_systemstate() {
  
  if (systemstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::IntelliSwing::ReturnMsg>(GetArenaForAllocation());
    systemstate_ = p;
  }
  return systemstate_;
}
inline ::IntelliSwing::ReturnMsg* DiviceStatus::mutable_systemstate() {
  ::IntelliSwing::ReturnMsg* _msg = _internal_mutable_systemstate();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.DiviceStatus.systemState)
  return _msg;
}
inline void DiviceStatus::set_allocated_systemstate(::IntelliSwing::ReturnMsg* systemstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(systemstate_);
  }
  if (systemstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(systemstate));
    if (message_arena != submessage_arena) {
      systemstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, systemstate, submessage_arena);
    }
    
  } else {
    
  }
  systemstate_ = systemstate;
  // @@protoc_insertion_point(field_set_allocated:IntelliSwing.DiviceStatus.systemState)
}

// float deviceTemperature = 5;
inline void DiviceStatus::clear_devicetemperature() {
  devicetemperature_ = 0;
}
inline float DiviceStatus::_internal_devicetemperature() const {
  return devicetemperature_;
}
inline float DiviceStatus::devicetemperature() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.DiviceStatus.deviceTemperature)
  return _internal_devicetemperature();
}
inline void DiviceStatus::_internal_set_devicetemperature(float value) {
  
  devicetemperature_ = value;
}
inline void DiviceStatus::set_devicetemperature(float value) {
  _internal_set_devicetemperature(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.DiviceStatus.deviceTemperature)
}

// float batteryInfo = 6;
inline void DiviceStatus::clear_batteryinfo() {
  batteryinfo_ = 0;
}
inline float DiviceStatus::_internal_batteryinfo() const {
  return batteryinfo_;
}
inline float DiviceStatus::batteryinfo() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.DiviceStatus.batteryInfo)
  return _internal_batteryinfo();
}
inline void DiviceStatus::_internal_set_batteryinfo(float value) {
  
  batteryinfo_ = value;
}
inline void DiviceStatus::set_batteryinfo(float value) {
  _internal_set_batteryinfo(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.DiviceStatus.batteryInfo)
}

// -------------------------------------------------------------------

// LogRequest

// int32 systemRange = 1;
inline void LogRequest::clear_systemrange() {
  systemrange_ = 0;
}
inline int32_t LogRequest::_internal_systemrange() const {
  return systemrange_;
}
inline int32_t LogRequest::systemrange() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.LogRequest.systemRange)
  return _internal_systemrange();
}
inline void LogRequest::_internal_set_systemrange(int32_t value) {
  
  systemrange_ = value;
}
inline void LogRequest::set_systemrange(int32_t value) {
  _internal_set_systemrange(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.LogRequest.systemRange)
}

// int32 processingLogrange = 2;
inline void LogRequest::clear_processinglogrange() {
  processinglogrange_ = 0;
}
inline int32_t LogRequest::_internal_processinglogrange() const {
  return processinglogrange_;
}
inline int32_t LogRequest::processinglogrange() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.LogRequest.processingLogrange)
  return _internal_processinglogrange();
}
inline void LogRequest::_internal_set_processinglogrange(int32_t value) {
  
  processinglogrange_ = value;
}
inline void LogRequest::set_processinglogrange(int32_t value) {
  _internal_set_processinglogrange(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.LogRequest.processingLogrange)
}

// -------------------------------------------------------------------

// LogMessage

// repeated string systemLog = 1;
inline int LogMessage::_internal_systemlog_size() const {
  return systemlog_.size();
}
inline int LogMessage::systemlog_size() const {
  return _internal_systemlog_size();
}
inline void LogMessage::clear_systemlog() {
  systemlog_.Clear();
}
inline std::string* LogMessage::add_systemlog() {
  std::string* _s = _internal_add_systemlog();
  // @@protoc_insertion_point(field_add_mutable:IntelliSwing.LogMessage.systemLog)
  return _s;
}
inline const std::string& LogMessage::_internal_systemlog(int index) const {
  return systemlog_.Get(index);
}
inline const std::string& LogMessage::systemlog(int index) const {
  // @@protoc_insertion_point(field_get:IntelliSwing.LogMessage.systemLog)
  return _internal_systemlog(index);
}
inline std::string* LogMessage::mutable_systemlog(int index) {
  // @@protoc_insertion_point(field_mutable:IntelliSwing.LogMessage.systemLog)
  return systemlog_.Mutable(index);
}
inline void LogMessage::set_systemlog(int index, const std::string& value) {
  systemlog_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.LogMessage.systemLog)
}
inline void LogMessage::set_systemlog(int index, std::string&& value) {
  systemlog_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:IntelliSwing.LogMessage.systemLog)
}
inline void LogMessage::set_systemlog(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  systemlog_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:IntelliSwing.LogMessage.systemLog)
}
inline void LogMessage::set_systemlog(int index, const char* value, size_t size) {
  systemlog_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IntelliSwing.LogMessage.systemLog)
}
inline std::string* LogMessage::_internal_add_systemlog() {
  return systemlog_.Add();
}
inline void LogMessage::add_systemlog(const std::string& value) {
  systemlog_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:IntelliSwing.LogMessage.systemLog)
}
inline void LogMessage::add_systemlog(std::string&& value) {
  systemlog_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:IntelliSwing.LogMessage.systemLog)
}
inline void LogMessage::add_systemlog(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  systemlog_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:IntelliSwing.LogMessage.systemLog)
}
inline void LogMessage::add_systemlog(const char* value, size_t size) {
  systemlog_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:IntelliSwing.LogMessage.systemLog)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LogMessage::systemlog() const {
  // @@protoc_insertion_point(field_list:IntelliSwing.LogMessage.systemLog)
  return systemlog_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LogMessage::mutable_systemlog() {
  // @@protoc_insertion_point(field_mutable_list:IntelliSwing.LogMessage.systemLog)
  return &systemlog_;
}

// repeated string processingLog = 2;
inline int LogMessage::_internal_processinglog_size() const {
  return processinglog_.size();
}
inline int LogMessage::processinglog_size() const {
  return _internal_processinglog_size();
}
inline void LogMessage::clear_processinglog() {
  processinglog_.Clear();
}
inline std::string* LogMessage::add_processinglog() {
  std::string* _s = _internal_add_processinglog();
  // @@protoc_insertion_point(field_add_mutable:IntelliSwing.LogMessage.processingLog)
  return _s;
}
inline const std::string& LogMessage::_internal_processinglog(int index) const {
  return processinglog_.Get(index);
}
inline const std::string& LogMessage::processinglog(int index) const {
  // @@protoc_insertion_point(field_get:IntelliSwing.LogMessage.processingLog)
  return _internal_processinglog(index);
}
inline std::string* LogMessage::mutable_processinglog(int index) {
  // @@protoc_insertion_point(field_mutable:IntelliSwing.LogMessage.processingLog)
  return processinglog_.Mutable(index);
}
inline void LogMessage::set_processinglog(int index, const std::string& value) {
  processinglog_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.LogMessage.processingLog)
}
inline void LogMessage::set_processinglog(int index, std::string&& value) {
  processinglog_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:IntelliSwing.LogMessage.processingLog)
}
inline void LogMessage::set_processinglog(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  processinglog_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:IntelliSwing.LogMessage.processingLog)
}
inline void LogMessage::set_processinglog(int index, const char* value, size_t size) {
  processinglog_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IntelliSwing.LogMessage.processingLog)
}
inline std::string* LogMessage::_internal_add_processinglog() {
  return processinglog_.Add();
}
inline void LogMessage::add_processinglog(const std::string& value) {
  processinglog_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:IntelliSwing.LogMessage.processingLog)
}
inline void LogMessage::add_processinglog(std::string&& value) {
  processinglog_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:IntelliSwing.LogMessage.processingLog)
}
inline void LogMessage::add_processinglog(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  processinglog_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:IntelliSwing.LogMessage.processingLog)
}
inline void LogMessage::add_processinglog(const char* value, size_t size) {
  processinglog_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:IntelliSwing.LogMessage.processingLog)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LogMessage::processinglog() const {
  // @@protoc_insertion_point(field_list:IntelliSwing.LogMessage.processingLog)
  return processinglog_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LogMessage::mutable_processinglog() {
  // @@protoc_insertion_point(field_mutable_list:IntelliSwing.LogMessage.processingLog)
  return &processinglog_;
}

// -------------------------------------------------------------------

// SensorStatistics

// int32 shot_count = 1;
inline void SensorStatistics::clear_shot_count() {
  shot_count_ = 0;
}
inline int32_t SensorStatistics::_internal_shot_count() const {
  return shot_count_;
}
inline int32_t SensorStatistics::shot_count() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SensorStatistics.shot_count)
  return _internal_shot_count();
}
inline void SensorStatistics::_internal_set_shot_count(int32_t value) {
  
  shot_count_ = value;
}
inline void SensorStatistics::set_shot_count(int32_t value) {
  _internal_set_shot_count(value);
  // @@protoc_insertion_point(field_set:IntelliSwing.SensorStatistics.shot_count)
}

// -------------------------------------------------------------------

// SiteCalibrationResult

// .IntelliSwing.ReturnMsg state = 1;
inline bool SiteCalibrationResult::_internal_has_state() const {
  return this != internal_default_instance() && state_ != nullptr;
}
inline bool SiteCalibrationResult::has_state() const {
  return _internal_has_state();
}
inline const ::IntelliSwing::ReturnMsg& SiteCalibrationResult::_internal_state() const {
  const ::IntelliSwing::ReturnMsg* p = state_;
  return p != nullptr ? *p : reinterpret_cast<const ::IntelliSwing::ReturnMsg&>(
      ::IntelliSwing::_ReturnMsg_default_instance_);
}
inline const ::IntelliSwing::ReturnMsg& SiteCalibrationResult::state() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.SiteCalibrationResult.state)
  return _internal_state();
}
inline void SiteCalibrationResult::unsafe_arena_set_allocated_state(
    ::IntelliSwing::ReturnMsg* state) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_);
  }
  state_ = state;
  if (state) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IntelliSwing.SiteCalibrationResult.state)
}
inline ::IntelliSwing::ReturnMsg* SiteCalibrationResult::release_state() {
  
  ::IntelliSwing::ReturnMsg* temp = state_;
  state_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::IntelliSwing::ReturnMsg* SiteCalibrationResult::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:IntelliSwing.SiteCalibrationResult.state)
  
  ::IntelliSwing::ReturnMsg* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::IntelliSwing::ReturnMsg* SiteCalibrationResult::_internal_mutable_state() {
  
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::IntelliSwing::ReturnMsg>(GetArenaForAllocation());
    state_ = p;
  }
  return state_;
}
inline ::IntelliSwing::ReturnMsg* SiteCalibrationResult::mutable_state() {
  ::IntelliSwing::ReturnMsg* _msg = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.SiteCalibrationResult.state)
  return _msg;
}
inline void SiteCalibrationResult::set_allocated_state(::IntelliSwing::ReturnMsg* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_);
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state));
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    
  } else {
    
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:IntelliSwing.SiteCalibrationResult.state)
}

// -------------------------------------------------------------------

// Firmware

// bytes sensorFirmware = 1;
inline void Firmware::clear_sensorfirmware() {
  sensorfirmware_.ClearToEmpty();
}
inline const std::string& Firmware::sensorfirmware() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.Firmware.sensorFirmware)
  return _internal_sensorfirmware();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Firmware::set_sensorfirmware(ArgT0&& arg0, ArgT... args) {
 
 sensorfirmware_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IntelliSwing.Firmware.sensorFirmware)
}
inline std::string* Firmware::mutable_sensorfirmware() {
  std::string* _s = _internal_mutable_sensorfirmware();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.Firmware.sensorFirmware)
  return _s;
}
inline const std::string& Firmware::_internal_sensorfirmware() const {
  return sensorfirmware_.Get();
}
inline void Firmware::_internal_set_sensorfirmware(const std::string& value) {
  
  sensorfirmware_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Firmware::_internal_mutable_sensorfirmware() {
  
  return sensorfirmware_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Firmware::release_sensorfirmware() {
  // @@protoc_insertion_point(field_release:IntelliSwing.Firmware.sensorFirmware)
  return sensorfirmware_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Firmware::set_allocated_sensorfirmware(std::string* sensorfirmware) {
  if (sensorfirmware != nullptr) {
    
  } else {
    
  }
  sensorfirmware_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sensorfirmware,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sensorfirmware_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sensorfirmware_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IntelliSwing.Firmware.sensorFirmware)
}

// bytes fpgaFirmware = 2;
inline void Firmware::clear_fpgafirmware() {
  fpgafirmware_.ClearToEmpty();
}
inline const std::string& Firmware::fpgafirmware() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.Firmware.fpgaFirmware)
  return _internal_fpgafirmware();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Firmware::set_fpgafirmware(ArgT0&& arg0, ArgT... args) {
 
 fpgafirmware_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IntelliSwing.Firmware.fpgaFirmware)
}
inline std::string* Firmware::mutable_fpgafirmware() {
  std::string* _s = _internal_mutable_fpgafirmware();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.Firmware.fpgaFirmware)
  return _s;
}
inline const std::string& Firmware::_internal_fpgafirmware() const {
  return fpgafirmware_.Get();
}
inline void Firmware::_internal_set_fpgafirmware(const std::string& value) {
  
  fpgafirmware_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Firmware::_internal_mutable_fpgafirmware() {
  
  return fpgafirmware_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Firmware::release_fpgafirmware() {
  // @@protoc_insertion_point(field_release:IntelliSwing.Firmware.fpgaFirmware)
  return fpgafirmware_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Firmware::set_allocated_fpgafirmware(std::string* fpgafirmware) {
  if (fpgafirmware != nullptr) {
    
  } else {
    
  }
  fpgafirmware_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fpgafirmware,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fpgafirmware_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fpgafirmware_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IntelliSwing.Firmware.fpgaFirmware)
}

// -------------------------------------------------------------------

// UpdateFirmwareResult

// .IntelliSwing.ReturnMsg FpgaState = 1;
inline bool UpdateFirmwareResult::_internal_has_fpgastate() const {
  return this != internal_default_instance() && fpgastate_ != nullptr;
}
inline bool UpdateFirmwareResult::has_fpgastate() const {
  return _internal_has_fpgastate();
}
inline const ::IntelliSwing::ReturnMsg& UpdateFirmwareResult::_internal_fpgastate() const {
  const ::IntelliSwing::ReturnMsg* p = fpgastate_;
  return p != nullptr ? *p : reinterpret_cast<const ::IntelliSwing::ReturnMsg&>(
      ::IntelliSwing::_ReturnMsg_default_instance_);
}
inline const ::IntelliSwing::ReturnMsg& UpdateFirmwareResult::fpgastate() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.UpdateFirmwareResult.FpgaState)
  return _internal_fpgastate();
}
inline void UpdateFirmwareResult::unsafe_arena_set_allocated_fpgastate(
    ::IntelliSwing::ReturnMsg* fpgastate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fpgastate_);
  }
  fpgastate_ = fpgastate;
  if (fpgastate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IntelliSwing.UpdateFirmwareResult.FpgaState)
}
inline ::IntelliSwing::ReturnMsg* UpdateFirmwareResult::release_fpgastate() {
  
  ::IntelliSwing::ReturnMsg* temp = fpgastate_;
  fpgastate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::IntelliSwing::ReturnMsg* UpdateFirmwareResult::unsafe_arena_release_fpgastate() {
  // @@protoc_insertion_point(field_release:IntelliSwing.UpdateFirmwareResult.FpgaState)
  
  ::IntelliSwing::ReturnMsg* temp = fpgastate_;
  fpgastate_ = nullptr;
  return temp;
}
inline ::IntelliSwing::ReturnMsg* UpdateFirmwareResult::_internal_mutable_fpgastate() {
  
  if (fpgastate_ == nullptr) {
    auto* p = CreateMaybeMessage<::IntelliSwing::ReturnMsg>(GetArenaForAllocation());
    fpgastate_ = p;
  }
  return fpgastate_;
}
inline ::IntelliSwing::ReturnMsg* UpdateFirmwareResult::mutable_fpgastate() {
  ::IntelliSwing::ReturnMsg* _msg = _internal_mutable_fpgastate();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.UpdateFirmwareResult.FpgaState)
  return _msg;
}
inline void UpdateFirmwareResult::set_allocated_fpgastate(::IntelliSwing::ReturnMsg* fpgastate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fpgastate_);
  }
  if (fpgastate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fpgastate));
    if (message_arena != submessage_arena) {
      fpgastate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fpgastate, submessage_arena);
    }
    
  } else {
    
  }
  fpgastate_ = fpgastate;
  // @@protoc_insertion_point(field_set_allocated:IntelliSwing.UpdateFirmwareResult.FpgaState)
}

// .IntelliSwing.ReturnMsg SensorSW = 2;
inline bool UpdateFirmwareResult::_internal_has_sensorsw() const {
  return this != internal_default_instance() && sensorsw_ != nullptr;
}
inline bool UpdateFirmwareResult::has_sensorsw() const {
  return _internal_has_sensorsw();
}
inline const ::IntelliSwing::ReturnMsg& UpdateFirmwareResult::_internal_sensorsw() const {
  const ::IntelliSwing::ReturnMsg* p = sensorsw_;
  return p != nullptr ? *p : reinterpret_cast<const ::IntelliSwing::ReturnMsg&>(
      ::IntelliSwing::_ReturnMsg_default_instance_);
}
inline const ::IntelliSwing::ReturnMsg& UpdateFirmwareResult::sensorsw() const {
  // @@protoc_insertion_point(field_get:IntelliSwing.UpdateFirmwareResult.SensorSW)
  return _internal_sensorsw();
}
inline void UpdateFirmwareResult::unsafe_arena_set_allocated_sensorsw(
    ::IntelliSwing::ReturnMsg* sensorsw) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sensorsw_);
  }
  sensorsw_ = sensorsw;
  if (sensorsw) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IntelliSwing.UpdateFirmwareResult.SensorSW)
}
inline ::IntelliSwing::ReturnMsg* UpdateFirmwareResult::release_sensorsw() {
  
  ::IntelliSwing::ReturnMsg* temp = sensorsw_;
  sensorsw_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::IntelliSwing::ReturnMsg* UpdateFirmwareResult::unsafe_arena_release_sensorsw() {
  // @@protoc_insertion_point(field_release:IntelliSwing.UpdateFirmwareResult.SensorSW)
  
  ::IntelliSwing::ReturnMsg* temp = sensorsw_;
  sensorsw_ = nullptr;
  return temp;
}
inline ::IntelliSwing::ReturnMsg* UpdateFirmwareResult::_internal_mutable_sensorsw() {
  
  if (sensorsw_ == nullptr) {
    auto* p = CreateMaybeMessage<::IntelliSwing::ReturnMsg>(GetArenaForAllocation());
    sensorsw_ = p;
  }
  return sensorsw_;
}
inline ::IntelliSwing::ReturnMsg* UpdateFirmwareResult::mutable_sensorsw() {
  ::IntelliSwing::ReturnMsg* _msg = _internal_mutable_sensorsw();
  // @@protoc_insertion_point(field_mutable:IntelliSwing.UpdateFirmwareResult.SensorSW)
  return _msg;
}
inline void UpdateFirmwareResult::set_allocated_sensorsw(::IntelliSwing::ReturnMsg* sensorsw) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sensorsw_);
  }
  if (sensorsw) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sensorsw));
    if (message_arena != submessage_arena) {
      sensorsw = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sensorsw, submessage_arena);
    }
    
  } else {
    
  }
  sensorsw_ = sensorsw;
  // @@protoc_insertion_point(field_set_allocated:IntelliSwing.UpdateFirmwareResult.SensorSW)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace IntelliSwing

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_IntelliSwingService_2eproto
